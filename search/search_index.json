{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"CG3207 Lab Manuals","text":"<p>Welcome to CG3207! In this repository, you will find the manuals for each of the 4 lab exercises you will complete for this course, as well as instructions on how to set up the tools you'll need. </p>"},{"location":"#lab-outline","title":"Lab outline","text":"<p>All labs will be conducted at Digital Systems and Applications laboratory, E4A-04-08. </p> Lab Description Marks Remarks 1 Familiarisation with HDL/FPGA and Assembly Language.   Omae wa mou shindeiru. 10 Individual exercise 2 Basic CPU design.    All your base are belong to us. 30 Teams of 2 or 3 students 3 ALU Design.   Billions of blue blistering barnacles. 20+5$ Teams of 2 or 3 students 4 Advanced CPU design.      It was the best of times, it was the worst of times. 15+10$ Teams of 2 or 3 students Total 90 = 45% of the module grade <p>The skeleton file repository contains all the files you need to download. </p>"},{"location":"#other-useful-pages","title":"Other useful pages","text":"<p>Vivado Installation Guide</p> <p>RISC-V Memory Map</p> <p>RISC-V Programming Guide</p> <p>ARM Memory Map</p> <p>ARM Programming Guide</p>"},{"location":"#lab-schedule-tentative","title":"Lab Schedule (Tentative)","text":"Week Monday Lab Date (18:00-21:00) Friday Lab Date (09:00-12:00) Activity Remarks 4 2 Sep 2024 6 Sep 2024 Lab 1 Intro 5 9 Sep 2024 13 Sep 2024 Lab 1 Demo, Lab 2 Intro 6 16 Sep 2024 20 Sep 2024 Lab 2 Consultation Recess 23 Sep 2024 27 Sep 2024 No Lab Session 7 30 Sep 2024 4 Oct 2024 Lab 2 Demo, Lab 3 Intro 8 7 Oct 2024 11 Oct 2024 Lab 3 Consultation 9 14 Oct 2024 18 Oct 2024 Lab 3 Demo, Lab 4 Intro 10 21 Oct 2024 25 Oct 2024 Lab 4 Consultation 11 28 Oct 2024 1 Nov 2024 No Lab - NUS Well-Being Day 12 4 Nov 2024 8 Nov 2024 Lab 4 Demo"},{"location":"#how-to-get-help","title":"How to get help","text":"<p>If you have any questions regarding the content of any of the labs, please follow these steps, in this order, to answer them.  </p> <ol> <li> <p>Please read the lab manual closely. We will try our best to keep the manual updated with any common errors, or issues, that you may face. </p> </li> <li> <p>If the lab manual does not answer your question, the skeleton file repository has a discussions page. Please search here for your question, in case it has already been answered before. We will leave questions and answers from previous semesters on this page, so over time, more and more information should be covered between here and the manuals. </p> </li> <li> <p>If you cannot find an answer to your question in the discussions either, then please create a new discussion. Make sure your title is as succinct, but descriptive, as possible, for the benefit of others who may search the issues page later. Also, do make sure you include all relevant details in the discussion content. This webpage offers some helpful advice on how to ask good technical questions. </p> </li> <li> <p>Please DO NOT send emails to the teaching staff asking technical questions regarding the lab activities. We will ignore all such emails, with no exception. Post all technical questions to the discussions page. This benefits others, because anyone who has the issue in the future can solve it quickly with a search. It also benefits you, because you may receive an answer faster from a classmate, than from us. </p> </li> </ol> <p>On that subject, please do join in and help each other out in the discussions as far as possible. </p>"},{"location":"#board-handling-guidelines","title":"Board Handling Guidelines","text":"<p>Like most development boards and PCBs, your FPGA board is fragile. Treat it with care and respect, as if it were your own. It is reasonably expensive at over S$500, and not so easy to get replaced. </p> <p>Here are some tips to take good care of your board:</p> <ul> <li>Do not touch the PCB tracks, or the components on the board. Static discharge can damage or destroy electronic components, and these boards can be particularly susceptible.</li> <li>Use the nice plastic box with foam lining to transport your FPGA board. Do not use a plastic bag or other plastic container to carry your boards, and most certainly don't put it bare in your backpack/tote/briefcase/whatever you bring to class.</li> <li>When using the board, keep it on a stable, flat surface. Do NOT have it hanging off the USB cable, or hanging off the edge of a table, or on your lap, or anywhere that isn't a suitable, solid surface.</li> <li>Absolutely DO NOT DROP your board. When moving it around, hold the board by the edges and make sure the USB cable is unplugged so as to minimize strain on the port and to avoid it getting caught on something.</li> <li>Avoid plugging and unplugging the micro-USB cable more than necessary. To reset the board, you can use the power switch on the top left of the board, or unplug the USB-A connector from your computer if really necessary. Micro USB is a notoriously fragile connector, and it's best to avoid putting more strain on it than necessary. USB-A is much sturdier so that end of the cable is not as much of a concern.</li> <li>Apply common sense and standard practices for taking care of electronics: don't eat or drink near your board in case you get crumbs (or worse, a spill) on the board. Don't throw the board around. Plug and unplug accessories with care. Be gentle when using the switches and buttons.## License</li> </ul> <p>NUS CG3207 Lab Manuals \u00a9 2024 by NUS CG3207 Team is licensed under CC BY-NC-SA 4.0 </p>"},{"location":"LICENSE/","title":"LICENSE","text":"<p>NUS CG3207 Lab Manuals \u00a9 2024 by NUS CG3207 Team is licensed under CC BY-NC-SA 4.0 </p>"},{"location":"arm_memmap/","title":"ARM Memory Map","text":""},{"location":"arm_memmap/#memory-map-of-our-arm-processor","title":"Memory Map of OUR* ARM Processor","text":"<p>*This memory map is not compliant with any standards/recommendations. It is just the choice/design of the CG3207 lecturer.</p> Address Attributes DESCRIPTION 0x00000000 to 0x000001FC RO (Read Only) Instruction memory (ROM). 128 words. Word addressable - only multiples of 4 are valid addresses. This might cause warnings about 2 unused bits, but that's ok. 0x00000200 to 0x000003FC RO Data (Constant) memory (ROM). 128 words. Word addressable - only multiples of 4 are valid addresses. 0x00000800 to 0x000009FC RW (Read/Write) Data (Variable) memory (RAM). 128 words. Word addressable - only multiples of 4 are valid addresses. 0x00000A00 to 0x00000BFC - Unused / unmapped. 0x00000C00 WO (Write Only) LED[15:8]. Only the least significant 8 bits written to this location are used. LED[7] is used to show the divided clock. LED[6:0] shows PC[8:2]. PC[1:0] will always be 0 and hence not shown. 0x00000C04 RO DIP switches. Only the least significant 16 bits read from this location are valid, corresponding to SW[15:0]. 0x00000C08 RO PushButton switches. [2:0] \u2192\u00a0\u00a0BTNL, BTNC, BTNR. Only the least significant 3 bits read from this location are valid.\u00a0BTND is used as RESET and\u00a0BTNU is used as PAUSE. 0x00000C0C RW UART Console (both in and out). UART Settings: Baud Rate 115200. 8-bit. No Parity. 1 Stop bit. More details are given below. Only the least significant 8 bits in this location can be read/written. UART and RealTerm page has more details, as well as a short tutorial on RealTerm, a very good console application. 0x00000C10 RO CONSOLE_IN_valid. 0x00000C14 RO CONSOLE_OUT_ready. 0x00000C18 WO 7-Segment LED display. The data written to this location will appear as an 8-digit hexadecimal number on the display. For the Basys 3 board, the two half-words will keep displaying in alternation. <p>Table 1: Memory map summary</p>"},{"location":"arm_memmap/#endianness","title":"Endianness","text":"<p>The instruction and data memory are WORD addressable (NOT byte-addressable) for our labs. =&gt; Endianness doesn't matter for our hardware. However, the Hex2ROM converter tool assumes a little-endian format by default. Endianness matters only when each byte in the memory has an address, but we read/write one word (4 bytes) in one go. For example, if we store two words 0xABCD1234 and 0xEF567890 in the memory starting at the address 0x00000000, the two words will be stored at word addresses 0x00000000 and 0x00000004 respectively. In a system with a little-endian processor, the byte address 0x00000000 will have the content 0x34, byte address 0x00000001 will have the content 0x12, byte address 0x00000003 will have the content 0xAB, byte address 0x00000004 will have the content 0x90, byte address 0x00000007 will have the content 0xEF. In CG3207 labs, we use a memory that cannot deal with byte addresses such as 0x00000001 and 0x00000002. We can only send word addresses (addresses which are multiples of 4), i.e., like 0x00000000 and 0x00000004, and get the corresponding 32-bit contents. Hence, for our hardware, endianness doesn't matter. However, we need to maintain consistency between our selection in Keil and the Hex2ROM converter tool.</p>"},{"location":"arm_programming/","title":"ARM Programming Guide","text":"<p>Keil MDK is an IDE for ARM assembly/C programming and simulation. The lite version (with 32K code/debug limit and nag-screen) is available for free. You can download it on ARM website.</p> <p>Note : The latest version is Keil MDK 5. However, you will need to install the legacy support for ARM7 which we are going to use in this module. It is easier to go with Keil MDK 4.</p> <p>We will be using Keil MDK 4 as it comes with a built in simulator* for many ARM based cores. This allows you to test your programs before you run it on the processor YOU made. We will be using ARM7 (a microarchitecture executing ARMv3 instruction set, not to be confused with ARMv7A/M/R instruction set architecture) in this module, which is somewhat similar to the ARM Cortex M3/M4 you used in LPC1769/STM32L4 (executing ARMv7M) at an assembly level but very different at the machine language level. There are some very significant differences though, which we will see as we go along.</p> <p>*Note that the STM32 / LPCXpresso IDE you used in EE2028/CG2028/EE2024 do not have a simulator - to test a program, you needed a microprocessor board.</p>"},{"location":"arm_programming/#creating-a-project-and-basic-settings","title":"Creating a Project and Basic Settings","text":"<ul> <li>To create a new project, Project &gt; New uVision project. Select a location (preferably an empty folder) and give a name (which will be the same as the name of the Hex file generated by the IDE, so remember the name you gave and the location).</li> <li>You will get a device selection screen. Expand ARM and choose ARM7 (Little Endian).</li> <li>On the project pane on the left, expand 'Target 1' &gt; right-click on Source Group 1. Select 'Add files to Group Source Group 1'.</li> <li>In the file selection window that comes up, in the drop-down list, change 'Files of type' to 'Asm Source file (*.s*, *.src, *.a*)'. Browse to the folder containing the assembly language source (.s) file and click 'Add'. Click 'Close' to dismiss the window (it won't disappear even after you select a file).</li> <li>Use this sample assembly language program -\u00a0ARM_sample.s. Please read the instructions in the comments carefully.\u00a0The example code will produce this error when you execute the instruction in line 39 (line 30 in the older version) - error 65: access violation at 0x00000804 : no 'write' permission. However, this does not cause any problem in real hardware - say, if you try this code on the processor you will be designing in Lab 2. Why?</li> <li>Screenshots illustrating settings are given below. To bring up the window :\u00a0Project -&gt; Options for Target 'Target 1'. Note that the correct window might come up only on the second try - thanks to the wonderful (sarcasm intended) Keil UI.</li> <li>Use\u00a0this file MMIO.ini in\u00a0Project -&gt; Options for Target -&gt; Debug -&gt; Initialisation file (see the screenshot below).</li> </ul> <p>*See bullet 7 above</p> <p></p> <p></p> <p>Figure 1(a)-1(f) : Project &gt; Options for Target '' <ul> <li>Please note that syntax highlighting might not work properly for some keywords.</li> </ul>"},{"location":"arm_programming/#programming-instructions","title":"Programming Instructions","text":"<ul> <li>Note that the assembler directives in Keil MDK are different from LPCXpresso IDE/GCC toolchain.\u00a0<ul> <li>For example, instead of\u00a0.word, Keil uses\u00a0DCD\u00a0directive.\u00a0</li> <li>The assembler directives can be found\u00a0here.\u00a0</li> <li>You might be particularly interested in DCD (.word), DSB (store bytes, for strings), SPACE (.lcomm), EQU (.equ).\u00a0</li> <li>Labels do not have a ':' following them.</li> </ul> </li> <li>PC relative adressing mode (LDR Rd, LABEL)\u00a0is identical to offset mode, where the base register is implicitly R15/PC (LDR Rd,\u00a0[R15, #offset]). The offset is calculated automatically by the assembler, as the assembler knows the address corresponding to LABEL. Please note that in ARMv3, reading R15/PC returns the current PC+8.\u00a0</li> <li>Instructions with R15/PC as an implicit or explicit source operand\u00a0(for example, PC relative load/source, Data processing instructions with PC as a source operand, Branch) can only use PC+8 value. However, if the R15/PC is specified as a destination (implicity or explicity), the result is written as such to R15/PC.\u00a0\u00a0</li> <li>DO NOT use pseudo-instructions.\u00a0<ul> <li>Instead of the pseudo-instruction\u00a0LDR\u00a0\u00a0R2, =variable1; use\u00a0LDR R2, variable1_addr\u00a0and\u00a0variable1_addr DCD variable1.\u00a0</li> <li>This will allow us to have control over where exactly\u00a0variable1_addr is stored in the memory, which\u00a0will make things easier when we insert our program into the Instruction (code) and Data (constant) ROMs created in the FPGA (in Lab 2).</li> <li>Keil/ARM assembler supports pseudo-instructions, but we just avoid it for the reason mentioned above.</li> </ul> </li> <li>You can refer to\u00a0ARM Architecture Reference Manual.pdf\u00a0to see ARMv3 instruction set architecture.</li> </ul>"},{"location":"arm_programming/#debugging-instructions","title":"Debugging Instructions","text":"<ul> <li> <p>To start a debug session, go to Debug &gt; Start/Stop debugging session. Debugging is done similar to how it is done in almost all IDEs. You can the see instruction in Hex, inspect register and memory values etc.  </p> </li> <li> <p>Make sure you do a 'Rebuild All' before you start a debug session ()\u00a0every time you make some changes in code. The IDE will not even prompt you to rebuild your code. It will continue using the binary from your last build, but the code displayed is the latest. This behavior it baffling, to say the least. To avoid it, always Rebuild All before starting a debug session.  </p> </li> <li> <p>Also note that when you do a CPU reset in the simulator (), the RAM (memory storing variables) in the simulator might not get reset.  </p> </li> <li> <p>Use memory windows to see the memory contents.\u00a0. You can click and edit the memory (only regions with read-write permission) if you want to manually change memory values during debugging.</p> </li> </ul>"},{"location":"arm_programming/#converting-hex-to-rom-initialization-code","title":"Converting .hex to ROM Initialization Code","text":"<p>Open the\u00a0Hex2ROM program (requires VS 2012 Redistributable)\u00a0and navigate to the .hex file for your project, generated by Keil MDK. The program converts the .hex file into a format which can be pasted into Wrapper.vhd/v (for Lab 2) or the ROMs for Lab 1. The format to be pasted is written into the clipboard as well as to a .vhd/v file having the same name as the .hex file.\u00a0 </p>"},{"location":"getting_started/","title":"Getting started with Vivado and HDL","text":""},{"location":"rv_memmap/","title":"RISC-V Memory Map","text":""},{"location":"rv_memmap/#memory-map-of-our-risc-v-processor","title":"Memory Map of OUR* RISC-V Processor","text":"<p>*This memory map is not compliant with any standards/recommendations. It is just the choice/design of the CG3207 lecturer.</p> <p>The data memory is further divided into constant (ROM) and variable memories (RAM).</p> Address Attributes DESCRIPTION 0x00000000 to 0x000001FC RO (Read Only) Instruction memory (ROM). 128 words. Word addressable - only multiples of 4 are valid addresses. This might cause warnings about 2 unused bits, but that's ok. 0x00002000 to 0x000021FC RO Data (Constant) memory (ROM). 128 words. Word addressable - only multiples of 4 are valid addresses. 0x00002200 to 0x000023FC RW (Read/Write) Data (Variable) memory (RAM). 128 words. Word addressable - only multiples of 4 are valid addresses. 0x00002400 WO (Write Only) LED[15:8]. Only the least significant 8 bits written to this location are used. LED[7] is used to show the divided clock. LED[6:0] shows PC[8:2]. PC[1:0] will always be 0 and hence not shown. 0x00002404 RO DIP switches. Only the least significant 16 bits read from this location are valid, corresponding to SW[15:0]. 0x00002408 RO PushButton switches. [2:0] \u2192\u00a0\u00a0BTNL, BTNC, BTNR. Only the least significant 3 bits read from this location are valid.\u00a0BTND is used as RESET and\u00a0BTNU is used as PAUSE. 0x0000240C RW UART Console (both in and out). UART Settings : Baud Rate 115200. 8-bit. No Parity. 1 Stop bit. More details given below. Only the least significant 8 bits in this location can be read/written.\u00a0UART and RealTerm is a good console application. 0x00002410 RO CONSOLE_IN_valid. 0x00002414 RO CONSOLE_OUT_ready. 0x00002418 WO 7-Segment LED display. The data written to this location will appear as an 8-digit hexadecimal number on the display. For the Basys 3 board, the two half-words will keep displaying in alternation. #### Table 1: Memory map summary"},{"location":"rv_memmap/#endianness","title":"Endianness","text":"<p>The instruction and data memory are WORD addressable (NOT byte-addressable) for our labs. =&gt; Endianness doesn't matter for our hardware. Endianness matters only when each byte in the memory has an address, but we read/write one word (4 bytes) in one go. For example, if we store two words 0xABCD1234 and 0xEF567890 in the memory starting at the address 0x00000000, the two words will be stored at word addresses 0x00000000 and 0x00000004 respectively. In a system with a little-endian processor like RISC-V, the byte address 0x00000000 will have the content 0x34, byte address 0x00000001 will have the content 0x12, byte address 0x00000003 will have the content 0xAB, byte address 0x00000004 will have the content 0x90, byte address 0x00000007 will have the content 0xEF. In CG3207 labs, we use a memory that cannot deal with byte addresses such as 0x00000001 and 0x00000002. We can only send word addresses (addresses which are multiples of 4), i.e., like 0x00000000 and 0x00000004, and get the corresponding 32-bit contents. Hence, for our hardware, endianness doesn't matter.</p>"},{"location":"rv_programming/","title":"RISC-V Programming","text":"<p>Use RARS assembler / simulator which can be downloaded from their GitHub repository. This requires Java to be installed in your system; Java 8 is available here.</p> <p>The .jar program can be run by double-clicking it. It is portable across operating systems and needs no installation. It is a very simple and easy to use application. Linux users may need to use <code>java -jar filename.jar</code> - note the <code>-jar</code> option required to run a Java archive. </p> <p>You can use riscv_assembly_sample.asm to get started. Download it, and open with RARS - File &gt; Open. Note : RARS assumes that SP(x2) and GP(x3) are initialized to 0x3ffc and 0x1800 respectively, and other registers are initialized to 0s. In the register file provided in the templates, only register zero (x0) is guaranteed to be 0, and others are uninitialized. You need to write a value to all registers other than x0 before you read them.</p> <p>Settings &gt; Memory Configuration &gt; Select Compact, Text at Address 0 &gt; Apply and Close.</p> <p>Write/modify the code as necessary. You may want to look at these pages -\u00a0RARS Supported Instructions,\u00a0Assembly Directives.</p> <p>Run &gt; Assemble.</p> <p>Debug and see if the program runs as intended. The standard debugging options are available. You can single step, run until a breakpoint (breakpoints are set using the checkboxes next to assembled code), backstep (a cool feature which not many simulators support), pause, stop, reset.</p> <p>File &gt; Dump Memory. You can also do so by clicking the button in the toolbar as shown below. First, select the .text memory segment. Save it as Hexadecimal text with a _text.hex suffix (say, program1_text.hex). This is the instruction memory.</p> <p></p> <p>Do the same thing with .data too, and save it in a different file, unless your program doesn't use any non-immediate constants at all. This is the data memory. </p> <p>Save the hex values of instruction memory followed by data memory in a file with name instructions_data.hex in the format:</p> <pre><code>//Copy paste hex values dumped from .text and remove comment\nDATA\n//Copy paste hex values dumped from .data and remove comment\n</code></pre> <p>Run the Python script with the command:</p> <pre><code>python convert_to_verilog.py\n</code></pre> <p>This script will output the code in memory_initialization.v</p> <p>Now, you can copy-paste this as contents of the instruction memory initialization and data memory initialization in Get_MEM.v/Wrapper.v. Align it properly by inserting 3 tabs in front.</p> <p>Note : The memory-mapped peripherals of RARS use a different address as compared to the one used by Wrapper. We will stick with the addresses in the Wrapper, and use memory locations to simulate the effect of peripherals - the peripherals in RARS have a slightly different behavior as compared to the one implemented in Wrapper/TOP.\u00a0This can be changed in the Wrapper if need be though.</p>"},{"location":"uart_realterm/","title":"UART and RealTerm","text":""},{"location":"uart_realterm/#uart-details","title":"UART Details","text":"<p>In the following lines, 'read's and 'write's are from the perspective of the RISC-V\u00a0processor (assembly language program), and act as 'console in' and 'console out' respectively.</p> <ul> <li>Read from the UART only if\u00a0CONSOLE_IN_valid is set. Similarly, write to the UART only if\u00a0CONSOLE_OUT_ready is set\u00a0 (not very important if the processor runs on a slow clock).</li> <li>Successive writes to the\u00a0UART (sw / STR\u00a0followed by\u00a0sw / STR, i.e.,\u00a0consecutive\u00a0sws / STRs in your assembly language program) are not supported. Similarly, successive reads (consecutive\u00a0lws / LDRs) are not supported.</li> <li> <p>Allow sufficient time for the program to read a character before sending the next character from RealTerm. Any character received while one character is waiting to be read would be ignored.\u00a0This shouldn't be a problem if your processor runs at high speed (CLK_DIV_BITS is low).</p> </li> <li> <p>A 32-bit number can be sent as hexadecimal in ASCII format (8 characters), which will require some processing in your program before it can be used as a 32-bit operand (note : '0' is 0x30 and 'A' is 0x41 in ASCII). It is a good idea to echo characters so that you can check whether UART has received it correctly.\u00a0Also, note that backspace doesn't\u00a0work to 'delete' the sent characters unless you implement such a functionality explicitly in your assembly language program.\u00a0</p> </li> <li> <p>If you use a console, some parts of your program could be repetitive, best implemented using a subroutine. A subroutine is normally implemented using a BL/jal instruction which we have not implemented. A workaround can be seen in the HelloWorld program for Lab 2.</p> </li> <li> <p>In the simulation with UART, setting radix to ASCII could help.</p> </li> <li>Read the instructions in Wrapper.v/vhd before using it.</li> </ul>"},{"location":"uart_realterm/#realterm","title":"Realterm","text":"<p>Realterm\u00a0is an amazing serial monitor program, which could be very useful. You can use this\u00a0for sending and receiving data through the UART console. Teraterm (used in EE2028) is fine too, just that RealTerm is TeraTerm on steriods. RealTerm needs .NET framework\u00a0to be installed.</p> <p></p> <p>Note : The baud rate used depends on the baud rate set in TOP.vhd. In the template provided, it is 115200.</p> <p></p> <p>Figure 1(a) and 1(b) : Screenshot illustrating RealTerm settings.</p> <p>RealTerm allows you to send and display data that is not necessarily ASCII. Sending and receiving raw bytes can be very very useful. In fact, it is THE most effective way to get data in/out of the system.  </p> <p>(to do: Provide a screenshot here illustrating sending bytes, and perhaps even an example assembly language program).</p>"},{"location":"lab1/lab1/","title":"Lab 1: Familiarisation with Assembly Language and HDL/FPGA","text":""},{"location":"lab1/lab1/#information","title":"Information","text":"<p>This lab aims to teach you the tools you will need for this module - namely:</p> <ul> <li>Assembly language programming and simulation for the RISC-V architecture, and</li> <li>HDL simulation and FPGA implementation</li> </ul> <p>This lab may seem quite confusing and tedious at first - this is normal, and nothing to be worried about. It's not directly related to what you're learning in the lectures, and some/all of the tools may be new to you. You might not fully understand the connection between all of the things that you do in this lab, and that's fine. It will all likely make sense once you start doing the subsequent labs, and if it doesn't (or if you just want to understand what you're doing), feel free to ask during the lab sessions, or in the the discussions) :) </p> <p>NOTE: Lab 1 is an individual exercise. While you will be in teams for later lab work, you will work on your own for this first one. </p>"},{"location":"lab1/lab1/#tasks","title":"Tasks","text":""},{"location":"lab1/lab1/#software-assembly-simulation-only","title":"Software (Assembly simulation only)","text":"<p>The goal of this section is to get you familiar with the RISC-V assembler/simulator and ARM assembler/simulator by simulating a sample program. </p> <p>Here, we will do a software simulation of an RISC-V based system with memory-mapped input-output. Assume that the system we are simulating has LEDs mapped to the address <code>0x00002400</code> (<code>0x00000C00</code> for ARM), such that the data written (using <code>sw</code> for RISC-V/<code>STR</code> for ARM) to this address location will appear on the LEDs. Also, assume that the system has DIP switches mapped to the address <code>0x00002404</code> (<code>0x00000C04</code> for ARM) such that the data read from this location (using <code>lw</code> for RISC-V/<code>LDR</code> for ARM) will reflect the positions of the switches. The program which does that is provided for you, with the details mentioned below. </p> <p>Simulate riscv_assembly_sample.asm or arm_assembly_sample.s. You should understand every line of code, and every directive, in this file - you might be quizzed on these later, hint hint nudge nudge. Read RISC-V Memory Map or ARM Memory Map to understand the program better. </p> <p>Modify the data in the location pointed to by DIPs and see if the location pointed to by LEDs reflects it. Please see the screenshot below which illustrates how to inspect/modify the memory at location <code>0x2400</code>/<code>0xC00</code> and <code>0x2404</code>/<code>0xC04</code>. The value you enter at the location <code>0x2404</code>/<code>0xC04</code> before executing instruction #4 (line 28 (23 for ARM) in the file) should go into the register <code>s4</code>/<code>R4</code> after instruction #4, and should be reflected at the location <code>0x2400</code>/<code>0xC00</code> after instruction #5 (line 29 (24 for ARM) in the code). Are they exactly the same? </p> <p></p> <p>Screenshot of addresses in RARS</p> <p></p> <p>Screenshot of addresses in the Keil MDK</p> <p>Change the <code>DELAY_VAL</code> and see if the delay introduced by the delay loop changes accordingly. </p> <p>Understand the assembly language instructions and the corresponding hexadecimal (binary) representations. During Lab 1 evaluation, you should be in a position to convert a given 32-bit binary/hex instruction to the corresponding assembly language instruction and vice versa.</p>"},{"location":"lab1/lab1/#hardware-hdl-simulation-hardware","title":"Hardware (HDL simulation + hardware)","text":"<p>Task: Display the Instruction (INSTR_MEM) and Data (DATA_CONST_MEM) ROM contents on the physical 7-segment display on the FPGA board. We are doing only a memory dump here; not executing an actual assembly language program.</p> <p>Templates for Verilog and VHDL for all the boards can be found in the skeleton file repository. Note the following:</p> <ul> <li>Whether line 29 of the assembly code (for ARM) is commented or not is fundamentally not important as we are doing only a memory dump, not executing an actual assembly language program.</li> <li>Choose the appropriate combination of files depending on the language you are using. Add only those files you need - one each of Top_Nexys.v/vhd, Seven_Seg_Nexys.v, Clock_Enable.v/vhd, Get_MEM.v/vhd, and one .xdc file. You are NOT obliged to use the templates - it is perfectly fine to have your own architecture.</li> <li>HDL files without any board suffixes are common for all boards.</li> <li>HDL files are common for Nexys 4 as well as Nexys 4 DDR boards. However, the .xdc files are different for the two boards.</li> <li>Seven_Seg files are available only for Verilog, not for VHDL. The Verilog file can be used if you are using VHDL. You need not modify this file anyway. Files/modules written in the two languages can be mixed freely!</li> </ul> Board Part number Settings Nexys 4 / Nexys 4 DDR XC7A100T-1CSG324C. Note : Nexys 4 / Nexys 4 DDR both use the same FPGA chip, but pin mappings and hence the .xdc file are different. If you use the wrong .xdc file, you get no warnings at all, (as Vivado cares only about the chip you are using, not the board) but the hardware will be non-functional! <ul> <li>In Lab 1, the assembly language code you created in the software part above (1) is not executed on hardware - we do not have a processor to execute the code yet!. Instead, you will just be dumping the binaries created from your assembly language code onto the 7-segment displays. In other words, you are NOT going to achieve the equivalent functionality as the software above for the hardware in this lab - that is for Lab 2. You will not be using the physical DIP switches for this part.</li> <li>INSTR_MEM and DATA_CONST_MEM ROMs have a capacity of 128 words each and store the instructions and constants in our program respectively. Note that both the memories are word addressable (not byte addressable). There are 128 locations, each location having 32 bits of content, addressed using 7 bits.</li> <li>[Not needed now] In Lab 2, we have to make sure that the assembly language programs we run on our processor generate only word addresses (addresses are in multiples of 4). In our processor, we will ignore the last two bits and connect the rest to address lines of the ROM.</li> <li>Please see the end of this section to see how to declare and use INSTR_MEM. DATA_CONST_MEM is also dealt with in the same way. ROM is a combinational circuit and doesn't need a clock. Input to each ROM is a 7-bit address, and output is the 32-bit content in the addressed location.</li> <li>Run the convert_to_verilog script, and select the .hex file generated when you build the assembly language program. This will cause the initialization of\u00a0Instruction and Data ROMs to be copied to the clipboard. This can be pasted into the .v/.vhd file using Ctrl+V.</li> <li>Display the contents of the Instruction and Data ROMs on the 7 segment display. The rate of display should be approximately (doesn't need to be exact) 1 instruction/data per second (in the order of 1 instruction per second is ok). </li> <li>You can also optionally choose to display it on the LEDs (displaying it on the 7-segment display is compulsory). As each location contains 32 bits through we have only 16 LEDs, display them in consecutive clock cycles*, with the most significant half-word first.  </li> <li>When the instruction ROM display has been completed, display the contents of the data ROM. Do this in a cyclical manner (infinite loop). Note that each ROM has a capacity of 128 words, but you will only have a small number of valid words. Hence,\u00a0depending on whether you initialize the unused memory to zero or not, the values that you get after all the instructions are finished could be zero or random.\u00a0This is fine and you need not skip those zeros / random values automatically. However, note that initializing the rest of the memory to zeros could make your Verilog simulation much slower.</li> </ul> <pre><code>    for(i = n; i &lt; 128; i = i + 1) begin  \n    \u00a0 \u00a0 INSTR\\_MEM\\[i\\] = 32'h0;  \n    end\n</code></pre> <ul> <li>When the pushbutton BTNU is pressed, the display rate should increase to approximately 4 instructions per second (4 times the original rate, whatever the original rate was). The idea is that you will be able to run the zeros/random part faster by pressing this button.  </li> <li>When the pushbutton BTNC is pressed, the display should pause. The student should be able to pause the display and interpret a 32-bit instruction (you will need to pause it two times to see a complete instruction, as you can only display half of one instruction at a time).</li> <li>Your hardware will have BTNU, BTNC, and clk as inputs (each is 1-bit), and 7-segment displays (32-bit) as output. These have to be mapped to the physical BTNs and 7-segment displays on the FPGA board using an appropriate .xdc file (see the Getting Started manual\u00a0if you are unsure how to use design constraints).\u00a0You should also uncomment the 3 lines related to clk at the beginning of the .xdc file - the create_clock constraint is to tell the synthesis tool that our hardware works based on a 100MHz clock - info the synthesis tool needs to optimize the circuit appropriately.</li> <li>[Design hint]: You can use a 9-bit counter. Bit 0 can be used to select the upper/lower half-words. Bits 7:1 can be used as addresses to both the ROMs. Bit 8 can be used to select the output of INSTR_MEM/DATA_CONST_MEM. The counter is designed such that it counts only once every ~2^26 clocks (approx) normally but will count once every ~2^24 clocks when\u00a0BTNU is pressed and will pause when\u00a0BTNC is pressed. This is just a suggestion - there could be other ways too to achieve the same functionality.</li> <li>Please follow the guidelines given in Chapter 2 while creating your hardware. Ideally, you should use only a single clock in your entire design - the clock of every sequential device should be connected directly to this clock. i.e., you should not use a clock divider.</li> <li>The HDL you write should be simulated using an appropriate testbench before you venture into hardware implementation. It is sufficient to demo and submit the testbench for the top-level module.</li> <li>You may refer to the\u00a0Getting Started manual\u00a0for help with creating and simulating HDL code, as well as for .xdc creation and FPGA implementation.\u00a0</li> <li>Debouncing is neither necessary nor very useful for the Lab 1 problem. Debouncing is necessary in situations where, say, you need to count the number of times a button is pressed, or when the button works in a 'toggle' manner (press once to activate something, press again to deactivate) - essentially only where the exact number of times the button is pressed or released matters (contact bounce can cause one press to be counted as many). Here, your system works with one speed when it is pressed, and another speed when it is released - contact bounce is not something that affects the functionality. However, a metastable filter could be useful, though probabilistically, it is fine without.</li> </ul>"},{"location":"lab1/lab1/#block-diagram-for-the-system","title":"Block Diagram for the system","text":"<p>Note: The same clk (100 MHz) is driving the 9-bit counter in the design above.</p> <p>Using enable as a clock will amount to using a clock divider.</p> <p>Enable is a signal that has an effect synchronously, i.e., the value of enable is checked only at the edges of clk.</p> <p>*It is also fine to use a pushbutton (say, BTND) which allows us to select the half-word instead of displaying half-words over consecutive clock cycles. The selection should work even when pause (BTNC) is pressed. In this case, you use an 8-bit counter, with bits 6:0 used as addresses to both the ROMs, and bit 7 used to select INSTR_MEM/DATA_CONST_MEM.</p> <p>The clock given by the Nexys 4 / Nexys 4 DDR / Basys 3 board is 100MHz. Use the idea illustrated above to implement a clock enable to slow down the speed of the target counter (count in the example below) / sequential element. Please note that the below is a sample code, you will need to modify it properly to adapt to your logic/requirements.</p> Verilog VHDL always @(posedge clk) begin  count_fast &lt;= count_fast+1; if(count_fast == 26'h3FFFFFF) // change it to a lower value (say 26'h0000004) for simulation* count_slow_enable &lt;= 1'b1;  else  count_slow_enable &lt;= 1'b0; // 1'b1 for simulation*;  end  always @(posedge clk)  begin  if(count_slow_enable)  count &lt;= count+1;  end process(clk)  variable count_fast :std_logic_vector(25 downto 0):=(others=&gt;'0');  begin  if clk'event and clk='1' then  count_fast := count_fast+1;  if count_fast = x\"3FFFFFF\" then -- change it to a lower value (say x\"0000004\") for simulation* count_slow_enable &lt;= '1';  else  count_slow_enable &lt;= '0'; -- '1' for simulation*;  end if;  end if;  end process; process(clk)  begin  if clk'event and clk='1' then  if count_slow_enable = '1' then  count &lt;= count+1;  end if;  end if;  end process; <p>_*Do either of the two depending on your situation.\u00a0_Else, you might have to wait for\u00a02^26 cycles\u00a0(for a ~1Hz clock) before you can see the effect of 1 clock edge!__</p> <p>The way a ROM can be created in HDL is shown below.</p> Language Declaration Usage Verilog reg [31:0] INSTR_MEM [0:127] ; // instruction memory type MEM_128x32 is array (0 to 127) of std_logic_vector (31 down to 0) INSTR_MEM[&lt;7-bit word address&gt;] INSTR_MEM(conv_integer(&lt;7-bit word address&gt;)) if the address is a std_logic_vector VHDL This is the declaration for the type MEM_128x32. INSTR_MEM and DATA_CONST_MEM need not be declared as initialization and declaration are done together INSTR_MEM(&lt;7-bit word address&gt;) if the address is an integer"},{"location":"lab1/lab1/#optional-tasks-for-those-new-to-fpgas","title":"Optional Tasks (for those new to FPGAs)","text":"<p>Go through the Getting Started manual, where the complete FPGA design flow is illustrated - design source creation and editing, simulation, synthesis, implementation, bitstream generation, and FPGA configuration. Note : For Nexys 4 / Nexys 4 DDR, the FPGA part number is XC7A100T-1CSG324C. For Basys 3 board, the FPGA part number is XC7A35T-1CPG236C. Appropriate changes will be required in the project settings.</p> <p>This manual provides an illustration of the tools you will use in CG3207 through examples of a simple combinational (full adder) and a simple sequential circuit (16-bit shift register). It will familiarize you with industry leader Xilinx's Vivado Design Suite - a comprehensive integrated development environment (IDE) for FPGA design flow, Digilent Inc.'s Nexys 4 Development Board featuring an FPGA from Xilinx's state-of-the-art Artix-7 family, and VHDL/Verilog.</p> <p>Program the FPGA using the simple_count.bit given in this zip file (VHDL) or this zip file (Verilog). See the counter in action. This can be used to test the board and will help you get started. Note : Works only for Nexys 4 board.</p> <ol> <li>Download the above file and unzip it.</li> <li>Open the <code>simple_count.xpr</code> Xilinx Vivado Project.</li> <li>Have a look a the code files <code>simple_count.vhd</code> (VHDL) / <code>simple_count.v</code> (Verilog), and <code>Nexys4_Master.xdc</code> in \\simple_count.srcs folder.</li> <li>Either Generate Programming File, or simply use the existing <code>simple_count.bit</code> file in <code>\\simple_count.runs\\impl_1\\</code>.</li> <li>Program the Nexys 4 board with the simple_count.bit file.</li> <li>Notice that LED0, LED1, LED2, and LED3 together behave like a 4-bit counter on the Nexys 4 board. The MSBs of a 30-bit string <code>000000000000000000000000000000</code> are shown on the LEDs. The rest of the string change values too fast for the human eye. Also, note that if the BTNC button on the Nexys 4 board is pressed, the counter is paused - refer to the VHDL/Verilog code (.vhd/.v) and constraints file (.xdc).</li> <li>Augment the sample counter (in step 1) as follows :     When a button DIR is pressed, the counter should toggle the count direction. Upon pressing the RESET button, the counter value should be reset (synchronously or asynchronously) to <code>0000</code> when counting up, and to <code>1111</code> when counting down.      The counter has 4 different speeds - 1x (the default speed), 2x, 3x, and 4x. A button SPEED is used to change the speed of the counter -  each press of SPEED increases the speed, and if the current speed is 4x, it wraps around to 1x.     Note : You will need to debounce DIR and SPEED buttons to observe the desired results (why?). However, debouncing is left as an optional task. The priority of buttons (i.e., what should happen when two or more buttons are pressed together) is left to your discretion.</li> </ol>"},{"location":"lab1/lab1/#submission-info","title":"Submission Info","text":"<ul> <li>Lab 3 will be evaluated in Week 5. The presentation schedule can be found on Canvas.\u00a0</li> <li>Please upload the Lab 3 files to Canvas within 1 hour of your demo in week 5, including the following files:  <ul> <li>.s/.asm file (assembly language program, if you have modified it)</li> <li>.v/.vhd files (RTL sources aka your synthesizable HDL, testbenches)</li> <li>.xdc\u00a0file</li> <li>.bit file</li> <li>Screenshot of simulation waveform (.jpg file). Note that all signal names should be captured.</li> </ul> </li> </ul> <p>in the format Lab1__.zip, e.g. Lab1_MON_A123456W.zip. DO NOT zip up the complete project folders or individual files one by one. The files should be the exact same files that you used for the demo. Additional marks will not be awarded for any fixes/improvements that you made to the code after the demo."},{"location":"lab1/lab1/#tips","title":"Tips","text":"<ul> <li>Read Chapter 2B thoroughly and make sure your code is synthesizable.</li> <li>If you want the clock to be effective only under certain situations, use a clock enable.</li> <li>Synchronize all inputs at the earliest possible opportunity.</li> <li>Synthesize each entity / module by setting it as the top-level module and check for errors / warnings.</li> <li>See the elaborated design to see if the schematic matches your intended design.</li> <li>Inspect the synthesis report to see if the primitives (basic digital building blocks) inferred make sense.</li> <li>Xilinx Vivado's text editor is not very good. You might want to use a better editor like Notepad++ to keep the code properly intended.</li> <li>It might take a bit of time, effort, and frustration before you are able to write good synthesizable code. Sometimes, you can\u2019t get a better teacher than experience, especially so when it comes to writing good Verilog code. Just hang in there and you will be ok soon. The best bet is to go through the notes and have the hardware in mind while writing the code.</li> <li>It is generally a good idea to use project folder paths that do not have spaces, special characters, etc.</li> </ul>"},{"location":"lab2/Template_Updates_Log/","title":"Work in progress - Cleanup Necessary","text":"<p>* New features in V2 * - Ability to use the hexadecimal text dump from RARS directly without any conversion software or copy-pasting needed. - Instruction and data memory sizes can be bigger than 128 words. Be mindful of the potentially increased synthesis time though. - Addresses except IROM_BASE and DMEM_BASE are hierarchically derived instead of hard-coding. - Byte and half-word write to data memory and 7-segment display (sb and sh support) - aligned memory addresses and pre-shifted/aligned data required. Please read the relevant comments and aaddutional instructions page carefully. --Note: byte and half-word read don't require any Wrapper support - you can simply read the whole byte, extract the byte/half-word, and extend as necessary. - Possible to use a different Memory Configuration from RARS, except supporting 32'hFFFF0000 as the MMIO base in the RARS default. MMIO_BASE = DMEM_BASE + 2**DMEM_DEPTH_BITS in all configs. - Possible to use block RAMs (sync read) for instruction and data memories in the pipelined version. Allows faster synthesis times and possibly clock rates for larger memory sizes. - Renamed for simplicity and concistency with assembly program labels: INSTR_MEM-&gt;IROM; DATA_CONST_MEM-&gt;DROM; DATA_VAR_MEM-&gt;DRAM. DROM and DROM combined into DMEM in v3 - Updated files: Wrapperv2.v, RVv2.v, and ProgramCounterv2.v (necessary only if the Memory Configuration is changed in RARS).</p> <p>To use FPGA block RAMs for instruction and data memories in pipelined version (Allows faster synthesis times and possibly clock rates for larger memory sizes): (Disclaimer: Not tested fully). Change to always@(posedge clk) where relevant. Read the comments for more info.  If enabled, Instr, ReadData_in are delayed by 1 cycle. Therefore, what you get can be used as InstrD, ReadDataW directly. MMIO reads are also delayed. Register file outputs are RD1E and RD2E directly if it is done for the register file.</p> <p>The required byte/half-word will still have to be extracted from ReadDataW and zero/sign extended in W stage if using lb/lbu/lh/lhu.</p>"},{"location":"lab2/Template_Updates_Log/#sizes-of-various-segments-base-addresses-and-peripheral-address-offsets","title":"Sizes of various segments, base addresses, and peripheral address offsets.","text":"<p>Set the number of bits for the byte address.  Depth (size) = 2DEPTH_BITS. e.g.,if DEPTH_BITS = 9, depth = 512 bytes = 128 words.  Make sure that the align directive in the assembly programme is set according to the sizes of the various segments. The size of a data segment affects the next segment alignment and address. Keep in mind that large memory sizes can cause synthesis times to be longer, esp if not using synch read (block RAM)</p> <p>Base addresses of various segments The RARS default memory configuration is IROM_BASE = 32'h00400000 and DMEM_BASE = 32'h10010000 in RARS. The RARS default MMIO base is 32'hFFFF0000, but this is hard to support. So we use MMIO_BASE = DMEM_BASE + 2**DMEM_DEPTH_BITS in all memory configurations We use compact memory configuration with .txt at 0 where IROM_BASE = 32'h00000000 and DMEM_BASE = 32'h00002000, but you can change this to either of the other two if you wish.</p>"},{"location":"lab2/lab2/","title":"Lab 2: Implementation of a RISC-V 32-bit (RV32I) Processor","text":""},{"location":"lab2/lab2/#objective","title":"Objective","text":"<p>In this lab, you will be implementing the basic RISC-V processor supporting only limited 32-bit integer instructions.</p> <p>Essentially, it should support the following instructions [HDL simulation as well as hardware](20 marks)</p> <ul> <li>add, addi, sub, and, andi, or, ori</li> <li>lw, sw</li> <li>beq, bne, jal (without linking, that is, without saving the return address).\u00a0</li> </ul> <p>Further, improve the processor by adding the following features\u00a0[HDL\u00a0simulation as well as hardware]</p> <ul> <li>lui,\u00a0auipc (5 marks)</li> <li>sll, srl, sra (5 marks)</li> </ul> <p>No extra marks will be awarded for performance enhancements / adding support for more instructions (that's for Labs 3 and 4). However, a lack of convincing demos (with carefully crafted assembly language programs) can result in the deduction of marks.</p>"},{"location":"lab2/lab2/#design-files","title":"Design Files","text":"<p>The design files can be found here -\u00a0Lab_2_Template_files\u00a0(Only Verilog version provided. ChatGPT can help you convert this to VHDL pretty well if you are a fan of VHDL). Import all the relevant files into your project - all the .v files, as well as TOP_.vhd and uart.vhd - irrespective of whether you use UART. Choose the appropriate constraint file for your board\u1db2. The files are pretty self-explanatory. It is possible to mix VHDL and Verilog files in the same project. Note that TOP/uart.vhd is the same as that for the ARM version. All other files have differences, though in many cases, the differences are minor. <p>The file hierarchy is as follows</p> <ul> <li>TOP_.vhd (top-level module for hardware implementation) \u2192 Wrapper.v (unit under test for simulation) \u2192 RV.v \u2192 Components of RV (PC_Logic.v, Decoder.v, ALU.v etc). <li>TOP_.vhd\u00a0\u2192 uart.vhd <li>test_Wrapper.v (top-level module for simulation) \u2192 Wrapper.v (unit under test for simulation) \u2192 RV.v \u2192 Components of RV (PC_Logic.v, Decoder.v, ALU.v etc).</li> <li>ALU.v\u00a0\u2192 Shifter.v</li> <p>Ensure that the top-level module is set correctly in your project. It should be TOP (TOP_.vhd) for implementation, and test_Wrapper for simulation.\u00a0It can be set by right-clicking the appropriate file under Design sources (for\u00a0implementation) and Simulation sources (for simulation) and choosing Set as Top. The Wrapper is a convenient testbed to plug your processor (RV) into and simulate it using test_Wrapper as the testbench - see below for more details on how to modify the test_Wrapper appropriately. The Wrapper provides instruction/data memory and a set of abstract peripherals with easy-to-view signals. The abstract peripherals of the Wrapper are converted to real protocol/interfacing signals (e.g., CONSOLE_IN/CONSOLE_OUT of the Wrapper to RX/TX of UART; anode and cathode activation signals of the 7-segment display) by Top_.vhd. Writing a testbench to simulate RV directly is unnecessary.  <p>There are basically 4 files you need to\u00a0populate / modify\u00a0\u00a0-\u00a0PC_Logic.v\u00a0,\u00a0Decoder.v\u00a0,\u00a0RV.v\u00a0; you will also need to paste your code / constant memories\u00a0into\u00a0Wrapper.v\u00a0(see the section on RISCV Programming Instructions below).\u00a0 A 5th file, ALU.v should also be modified to incorporate shifts.</p> <p>Some other important considerations : *   Ensure the top-level module for synthesis is TOP (TOP.vhd) for synthesis (by right-clicking the file under Design Sources). *   Ensure that the top-level module is test_Wrapper (test_Wrapper.v) for simulation (by right-clicking the file under Simulation Sources) - this is especially important as Vivado might pick up TOP as top-level module for simulation, which is wrong. *   You might also need to modify\u00a0CLK_DIV_BITS in TOP.vhd\u00a0depending on the processor clock speed you want to achieve (keep it to a low\u00a0number like 5 if you are using UART). This need not be changed for simulation as TOP_.vhd is not simulated.  *   Read the comments (especially about the input and output ports / interfaces) in the Wrapper.v carefully.</p> <p>\u1db2It is a good idea to delay importing the constraints file and the TOP_.vhd file until you are ready to test on hardware. Not having the constraints file during the design / simulation phase can help avoid some warnings related to synthesis when you try synthesizing a module that does not have the interfaces specified in the constraints file. Alternatively, import it, but keep it disabled until you need it in Project Manager &gt; Sources &gt; Constraints &gt; right-click and Disable File. <p>Wrapper.v for ARM and RISC-V are almost identical. The only real difference is in the memory map.</p>"},{"location":"lab2/lab2/#design-requirements","title":"Design Requirements","text":"<ul> <li>You are required to simulate your design and verify its functionality.\u00a0All debugging should be done in simulation, not in hardware. Furthermore, while developing and testing your design, you should also try synthesizing to ensure that your design is synthesizable without avoidable warnings and errors.</li> <li>All arithmetic, logical, and shift operations on 32-bit numbers should be done in the ALU, except for the new PC (PC+ aka PC_IN) computation.<ul> <li>You should use '+' on 32-bit numbers only in 2 statements -&gt; one to compute the new PC value, and one statement in ALU.<ul> <li>In other words, only 2 32-bit adders can be used in the whole system.</li> <li>A single-cycle processor cannot be implemented with less than 2 adders, but a multi-cycle design can be - this will require the ALU to be used for PC increment in a second cycle for the same instructions.</li> </ul> </li> <li>Do not implement your own carry look ahead or ripple carry adders. The '+' operator synthesizes a circuit that makes use of the built-in carry acceleration logic built into most FPGAs (carry chain, carry lookahead logic - Google for CARRY4). However, if you insist on implementing your own adder logic for the sake of learning, please go ahead. It will use the general-purpose fabric/routing, which will almost certainly be slower (doesn't matter for lower frequencies though).</li> <li>\"=\" should not be used on 32-bit numbers for Lab 2.<ul> <li>The comparison for conditional branch should be done inside the ALU through subtraction.</li> <li>\"=\" may be used in other places such as the control unit, to implement multiplexers in the datapath, for checking the value of counter(s) for Lab 3 MCycle unit, etc., but this comparison is done on values that are much less than 32 bits.</li> <li>You may need \"=\" on 32-bit numbers in Lab 4 if you are implementing branch prediction, but that is optional and far away from where we are now :).</li> </ul> </li> <li>All Shift operations on 32-bit numbers should be done in the Shifter unit.</li> </ul> </li> <li>DO NOT create additional entities/modules. Components such as multiplexers are easily implemented using when-else / with-select / if / case statements. Leave PC_Logic and Decoder separate (do not combine them into one ControlUnit entity). However, the interfaces for entities could be modified slightly to meet the design requirements.<ul> <li>DO NOT modify the ports of the entity RISC-V, unless you want to take responsibility for the top-level wrapper module.</li> </ul> </li> <li>It is a good idea to use '-' (VHDL) or 'X' (Verilog) for don't cares, as it could simplify the combinational logic. However, there are 2 issues<ul> <li>Using don't cares with signals which change the processor state (RegWrite, PCSrc, MemWrite) would make the system vulnerable to illegal instructions.</li> <li>Don't cares can cause different behavior in simulation and synthesis. Don't cares are treated as a don't cares in simulation, whereas in synthesis, it could be a random 0 or 1 (whichever simplifies logic better).</li> </ul> </li> <li>Reset resets only the program counter. The register initial values are not guaranteed to be zero. This requires you to write to a register before using/reading it.</li> <li>you might need to modify your Lab 1 program to use only those instructions you have implemented in YOUR processor\u00a0(and simulate it in RARS to ensure the functionality) before you get started</li> <li>Use your own, well-crafted assembly language programs for a convincing demo (to demonstrate that all the required instructions and variants work). One single program demonstrating all the features would be desirable. By 'convincing demo', what we mean is having an assembly language program that tests all the features of all instructions of a particular type. For example, if you demonstrate addi, you don't really have to show andi, ori\u00a0as it can be expected to work, as the datapath activated is the same. Instructions such as conditional branches should be used such as both possibilities - i.e., branch taken and branch not taken should be demonstrated. In other words, it should provide an exhaustive 'coverage' of your HDL code. Your program should be crafted such that if one instruction misbehaves, the overall behavior of the program should be different (this is the case for most programs, as long as you use the result from every instruction in a subsequent instruction).</li> <li>The assembly language program you use, should be (obviously) such that only those instructions that you have implemented in your HDL are used.</li> <li>The provided HelloWorld program is perhaps NOT the first assembly language program you should attempt on your processor. Use the Lab 1 assembly language program\u00a0(with appropriate modifications) instead. HelloWorld\u00a0is neither meant to be a program for you to get started nor meant to be a comprehensive program that tests everything. It is just a fancy\u00a0example program.\u00a0Make sure that all the instructions used by the assembly programme are implemented in your design (HDL) before you can expect the functionality!</li> <li>The provided test_Wrapper is meant to test the HelloWorld assembly language program and provides stimuli simulating a UART Console. Slight modifications will be needed to test other assembly language programs you write.\u00a0For example, if you are giving inputs using DIP switches, you will need to provide appropriate stimuli, i.e., DIP = something at an appropriate point in time in your testbench.</li> <li>You could use the program that you simulated in RARS in Lab 1 as a starting point if you have implemented lui and auipc. However, you will need to make appropriate modifications to include instructions such as DP reg type, bne, and shifts in a meaningful manner. The test_Wrapper should be modified to give appropriate stimuli, as mentioned in the previous point. You can use it even before incorporating lui and auipc, but you will need to change it such that s1 and s2 are loaded from memory.</li> <li>There is no requirement that you should use all the peripherals supported by the Wrapper. As long as your demo is convincing, it is fine to use only a limited set of peripherals (say, LEDs and DIP switches - at least one input and one output). RISC-V Memory Map\u00a0page has more details about the address and usage of the supported peripherals.</li> <li>You can add more peripherals (RGB LED, accelerometer, VGA display, etc.) to the Wrapper if you wish. The corresponding changes will also need to be done in the top-level .vhd and .xdc files.</li> <li>Learn how to use debugging options such as single stepping, breakpoints, running for a specified time, etc which can help tremendously. However, note that some options such as single stepping work a bit differently from conventional software debugging, due to the inherent parallel nature of HDLs, as well as the fact that non-blocking assignments do not have an instantaneous effect on the LHS. Some additional info is given in the Tips section, and there is a demo on this during the lab briefing.</li> </ul>"},{"location":"lab2/lab2/#risc-programming-instructions","title":"RISC Programming Instructions","text":"<p>Please follow the instructions in\u00a0the\u00a0RISC-V Programming\u00a0page to configure RARS and to write programs. The .hex file generated by the program is inserted into the ROMs within Wrapper.v to \"program\" the RISC-V processor using the procedure mentioned on that page.</p> <p>Simulate your assembly language program thoroughly - else when something goes wrong, you won't know if the problem is with your HDL code (hardware) or the assembly language program (software).</p>"},{"location":"lab2/lab2/#tips","title":"Tips","text":"<ul> <li>Please SIMULATE your design before spending your time on bitstream generation. Make sure your design synthesizes without warnings (if at all there are warnings, you should know the reasons and you should ensure that the warnings do not affect the functionality). If you don't simulate and click 'generate bitstream' hoping it would work on the board, you are probably wasting your time. This can't be emphasized enough.</li> <li>Synthesize modules that you edit, such as decoder and conditional logic by setting them as top-level modules even before simulation. The synthesis tool is much smarter than the simulation tool - synthesis reports and warnings can give you a wealth of information.</li> <li>Looking at RTS Analysis &gt; Open Elaborated design gives you insights into the schematic (block design) inferred from your code. This can be very useful in debugging. Pay particular attention to the bit widths for each connection etc.<ul> <li>You can get even more information from the synthesis report.</li> </ul> </li> <li>You will get a warning about indices_reg. This is related to the seven-segment display and can also be ignored. You will also get warnings about Funct7 bits other than Funct7[5] being unused. This is also expected.</li> <li>You may also get warnings about Shifter connections and ALUFlags until you connect them.</li> <li>If you are synthesizing after setting a module other than TOP as the top-level module, you will get warnings such as those below. If your intention is to check the synthesizability of modules one by one, these warnings can be safely ignored (Why?).<ul> <li>'set_property' expects at least one object.      </li> <li>create_clock:No valid object(s) found for '-objects [get_ports CLK_undiv]'.     </li> </ul> </li> <li>You can get a very very good sense of whether it will work on hardware by doing a\u00a0post-synthesis functional simulation by Simulate &gt; Post-synthesis functional simulation. The same testbench can be used, so it requires zero extra effort. However, debugging is much harder than it is with behavioral simulation as some of the internal signals are optimized away and/or renamed (still easier than it is with hardware). For post-synthesis functional simulation, either the Wrapper or the TOP should be set as the top-level module for synthesis, and then the module should be synthesized before it can be (Post-synthesis) simulated.</li> <li>By default, Vivado will run significantly slower in Windows than in Linux, due to the differences in the number of threads used. A workaround is mentioned here - https://docs.amd.com/r/2021.2-English/ug904-vivado-implementation/Multithreading-with-the-Vivado-Tools</li> <li>If you try to run the design from a 100 MHz clock directly (CLK_DIV_BITS = 0, i.e., without dividing the clock), you will most certainly get a critical warning that the timing constraints are not met (Why?).\u00a0 Your design may or may not work on hardware, and it is unreliable even if it works. A pipelined design (Lab 4) should work directly from 100 MHz.\u00a0</li> <li>You can go into the subunits and see their value for each instruction (Scope-Objects) - this is much easier than what most of you think. This is more powerful than dragging the various signals into the waveform. Note that the values you see are those at the time the simulation has stopped/paused, not the time corresponding to the yellow vertical bar in the waveforms window. Double-clicking the Scope-Objects will lead you to the source code - you can then hover the mouse pointer above various objects to see their values.</li> <li>Make sure your radix in the waveform window / Scope-Objects is set correctly. Looking at hexadecimal and assuming them to be decimal or vice versa is a common mistake. Saving the waveform window (.wcfg) and adding it to the project will ensure that such settings get saved. For Console input/output, setting the radix to ASCII can be useful.</li> <li>Have the RARS simulator side by side so that you can compare the register/memory values between that in RARS and HDL register/memory objects. While you single step in RARS, you can also run by 10 more ns to have the same effect in HDL simulation. It helps to have the PC and Instr values in the waveform window to see the correspondence between RARS and HDL simulations, i.e., to ensure that you are looking at the same instruction on the two tools.</li> <li>If you get a number of warnings (~100) about unconnected stuff being removed, chances are that you haven't initialized the ROMs.</li> <li>The default processor clock frequency is 5 MHz which is ideal for UART, but too fast for LEDs - you will see the LEDs constantly lit, but different LEDs may have different brightness (why?). To see the output on LEDs, you need to have the LEDs changing state slow enough. There are two ways to do it - 1) by using a slow clock for the processor. This is done by setting the CLK_DIV_BITS to a value of around 26. 2) by having a fast clock CLK_DIV_BITS\u00a0= 1 for 50MHz), but using software delays (using a high value for DELAY_VAL between LED writes).     However, note that you should use a very low DELAY_VAL during simulation. Else, you might have to run simulation for a long time to get past the delay. Make sure you change either of them to a high value before implementation / bitstream generation     Similar considerations apply while sending data via UART.</li> <li>To implement lui and auipc, you will need to have a multiplexer at SrcA. The ALUSrcA control signal needs to be implemented properly too.</li> <li>The signals connected to the ports are given the same name as the ports themselves. So making the datapath connection is as easy as having a concurrent statement (VHDL) such as\u00a0Opcode\u00a0\u00a0&lt;= Instr(6 downto 0) / continuous assignment\u00a0(Verilog) such as assign Opcode\u00a0\u00a0\\= Instr[6: 0].</li> <li>Don't forget to Relaunch simulation (not just Restart) once you have made any changes to your HDL.</li> </ul>"},{"location":"lab2/lab2/#submission-info","title":"Submission Info","text":"<ul> <li>You will have to demonstrate your design during your designated lab session\u00a0in\u00a0Week 7. The presentation schedule can be found on Canvas.\u00a0</li> <li>One single program demonstrating all the features would be desirable.</li> <li>Please upload a\u00a0single archive containing all the relevant files to Canvas\u00a0within 1 hour of your demo.</li> <li>Include<ul> <li>.vhd/.v files you have created/modified [\u00a0RTL Sources, Testbench(es) ]</li> <li>.bit\u00a0files\u00a0</li> <li>.asm\u00a0files</li> <li>a\u00a0readme.txt, mentioning the purpose of each file (only those you have created / modified) briefly</li> </ul> </li> </ul> <p>in an archive with the filename Lab2_.zip, e.g. Lab2_Monday01.zip. One submission per group is sufficient \u2013 if there are multiple submissions, the file with the latest timestamp will be taken as the final submission.\u00a0Do not\u00a0zip and upload the complete project folder \u2013\u00a0only those files mentioned above should be included.\u00a0The files should be the exact same files that you used for the demo."},{"location":"lab2/lab2_schedule/","title":"Lab2 schedule","text":""},{"location":"lab2/lab2_schedule/#nav_exclude-true","title":"nav_exclude: true","text":""},{"location":"lab3/lab3/","title":"Lab 3: Multiplication / Division units","text":""},{"location":"lab3/lab3/#tasks","title":"Tasks","text":"<p>Lab 3 involves 2 compulsory tasks and one open-ended task.</p> <p>1) You will incorporate division (both signed and unsigned) into the MCycle unit given\u00a0[HDL\u00a0simulation only] (13 marks).</p> <ul> <li>The design files can be found here (VHDL) and here\u00a0(Verilog - please do not change the non-blocking assignments in the IDLE_PROCESS to blocking, as it is necessary to circumvent a certain non-deterministic behaviour from Verilog simulator). Please go through the comments carefully to understand its operation.</li> <li>Simulate it using a good testbench, and synthesize the MCycle unit by setting it as the top-level module to make sure it synthesizes without warnings\u00a0(unless you are sure it can be ignored) before doing the next task (incorporating it into the processor).</li> <li>You can assume that the divisor is never zero.</li> </ul> <p>2) Incorporate MCycle unit into your processor so that it can execute 32-bit variants of\u00a0mul and divu for RISC-V (MUL and DIV for ARMc3) [HDL\u00a0simulation as well as hardware] (7 marks).</p> <ul> <li>For RISC-V, mul and divu  are available in the Multiply extension instruction set - implement the word (32-bit) versions. There is no DIV instruction in ARMv3, so DIV can be done by cannibalizing MLA instruction. The idea is to just use the format of MLA instruction, but the machine will be doing division instead. This will limit your ability to simulate in Keil assembler though. </li> <li>The destination register should contain quotient. The remainder can be discarded.</li> <li>For RISC-V, divu performs unsigned division. (For ARMv3 assume DIV performs unsigned division.)</li> <li>Since mul/MUL writes only the 32-bit result, there is no difference between signed and unsigned variants.</li> <li>In ARMv3, multiplication instruction can set 'Z' and 'N' flags, but this functionality is not a requirement for Lab 3.</li> <li>Your control unit will need to be modified to generate 'Start' and 'MCycleOp' control signals.</li> <li>Complement of 'Busy' can be used as the write enable for the PC. This will stall the processor until the multicycle operation is complete.</li> <li>Your datapath should be modified to make the appropriate connections to and from the MCycle unit. You will need a multiplexer and a control signal to combine the outputs from ALU and MCycle.</li> <li>div (signed division) mulh variants (upper word) and rem variants (remainder) are not required to be implemented for RISC-V, though it takes very little extra effort (except maybe mulhsu). For ARM implementing instructions that generate 64-bit results (SMULL, UMULL, etc) is not a requirement.</li> <li>You can refer to the ARM Architecture Reference Manual (uploaded on Canvas), page A4-66 for MUL instruction format and page A4-54 for MLA instruction format. </li> </ul> <p>3) You can improve the given signed multiplier implemented in step 1 to score marks for performance enhancement\u00a0[Post-synthesis simulation; showing on hardware is left to your discretion] (5 marks).</p> <pre><code>Some suggestions for improvement are given below. You need not do all of them. **Keep in mind that performance improvement carries only 5 marks**, and we will be evaluating only one improvement. The purpose is to incentivize some exploration. However, **spending too much time on this is not recommended**.\n</code></pre> <ul> <li>You can try different techniques to strike a good trade-off between hardware complexity and the number of cycles required for multiplication (for example, 16 cycles instead of 32 or 16, but with more hardware) - the multiplication implemented in the sample code is very inefficient (intentionally).</li> <li>You could use a single adder for multiplication and division within the MCycle unit.\u00a0You could even take it one step further by reusing the same adder from the ALU (thus saving one additional adder, but will take a lot of effort, not worth 5 marks). The latter will need to modify the ports for the MCycle unit.</li> <li>You can implement Booth's multiplication algorithm or other efficient algorithms you can find on the internet.</li> <li>DO NOT implement a single cycle multiplier - FPGAs have built in multipliers/DSP units, which are inferred when you use '*' operator. This is much more efficient than any array adder based multipliers you can implement, but we don't want to be using it in CG3207.</li> </ul>"},{"location":"lab3/lab3/#design-instructions","title":"Design Instructions","text":"<ul> <li>You are required to have your own, comprehensive program to have a convincing demo. Only one assembly language program (and hence one bitstream) will be allowed for demo.</li> <li>If you are using the UART console, you can set the radix to hexadecimal in the 'Display' tab of RealTerm.</li> </ul>"},{"location":"lab3/lab3/#submission-info","title":"Submission Info","text":"<ul> <li>Lab 3 will be evaluated in Week 9. The presentation schedule can be found on Canvas.\u00a0</li> <li>Please upload the Lab 3 files to Canvas within 1 hour of your demo in week 9, including the following files:<ul> <li>.v/vhd\u00a0files you have created/modified [\u00a0RTL Sources, Testbench(es) ]\u00a0</li> <li>.bit\u00a0files\u00a0</li> <li>.s/.asm\u00a0files (assembly programs)</li> <li>.ppt\u00a0file - 1 to 4 slides showing performance enhancement techniques you have implemented as task (3) above.</li> </ul> </li> </ul> <p>in an archive with the filename GroupXX_Monday/Friday_Lab3.zip (replace XX with your group number) and upload it to Canvas. One submission per group is sufficient \u2013 if there are multiple submissions, the file with the latest timestamp will be taken as the final submission. Do not\u00a0zip and upload the complete project folder \u2013\u00a0only those files mentioned above should be included.\u00a0The files should be the exact same files that you used for the demo.</p>"},{"location":"lab4/Using_Compiled_Code/","title":"Lab 4: Using Compiled Code and New Peripherals","text":""},{"location":"lab4/Using_Compiled_Code/#using-compiled-code","title":"Using Compiled Code","text":"<p>It is strongly recommended to use the new template files at https://github.com/NUS-CG3207/lab-skeletons/tree/main/lab2/V3 if you're using compiled code.  </p> <ul> <li>If you do not upgrade, you will have to manually segregate static constants and variables to ROM and RAM, and static variables can only be zero-initialized.  </li> <li>If you're upgrading from version 1 of template files, you will need to change Wrapper, TOP, and RV. Since you modified RV to implement the processor, you will need to merge changes, which is quite easy. </li> <li>If you're upgrading from version 2, only Wrapper and TOP will need to be changed.  </li> <li>Use ProgramCounterv2 if your memory configuration is such that .text starts at a location other than 0. You will need to do this if you want to load a full-resolution image (see the OLED section below). </li> <li>Use RegFilev2 if you wish to use synchronous read, which may be used to infer block RAMs.  </li> </ul> <p>You can use the .C file in the folder above as a sample. The corresponding .asm is also provided for reference.  </p> <p>Please note some other points below.</p> <ul> <li>To the extent possible, it is a good idea to test your algorithms (e.g., masking and shifts to deal with bytes within a word.) in a standard C compiler, making appropriate changes (e.g., printf and scanf/hardcoding to simulate actual system input and output) to run in a desktop environment.</li> <li>Follow the Godbolt settings as shown.</li> <li>The default Godbolt language maybe C++, change it to C. C++ compiler does stuff like name mangling which we can do without.</li> <li>Clang produces more comprehensible code than GCC, though sometimes at the expense of increased code size.</li> <li>In fact, GCC with -Os -fwhole-program can produce very compact code, but can be pretty hard to make sense of. In any case, do not use the trunk version of GCC.</li> <li>Do not use library functions such as printf.\u00a0If need be, implement your own, simple versions of these functions.</li> <li>Make sure that only those instructions supported by your processor are generated. Check in the RARS execute window for actual instructions.</li> <li>Typically, the only essential change needed for the assembly code generated by Godbolt/Clang is to have a .data inserted just before the data declarations.</li> <li>Check the actual number of instructions (not lines of code as some instructions are pseudoinstructions). Make sure the size is set in Wrapper IROM_DEPTH_BITS as appropriate. e.g., should be 10 if the number of instructions is &gt;128 and &lt;=255.</li> <li>DMEM_DEPTH_BITS should also be changed as appropriate. It should be 10 for using the original peripheral addresses in the previous versions of the wrapper (as the DROM+DRAM is 256 words). However, if you need more memory (DRAM+DROM) such as what you will need when you load images, change this. STACK_INIT and MMIO_BASE in your C source code should also be modified to correspond to this.</li> <li>Stack pointer is set to point to the top of RAM initially (STACK_INIT). The stack is full-descending, so the first value is pushed to STACK_INIT-4.</li> <li>In the example C code (in the repo above), this is done via inline assembly. Alternatives are<ul> <li>Insert an assembly statement <code>la sp, STACK_INIT</code> as the first line in your assembly code .text section.</li> <li>Hard-code <code>RegBank[5'b00010]</code> initialization value to <code>STACK_INIT</code> via an <code>initial</code> block in RegFile.v. Of course, <code>STACK_INIT</code> should have a proper value via a <code>.equ</code> or be passed as a parameter to the RegFile module.</li> </ul> </li> <li>Make sure the correct memory config is selected in RARS.</li> <li>The first few instructions that save Callee saved registers to the stack can be deleted safely - do a sanity check to see if this is really the case nevertheless. There is no caller for main(). Ensure that the inline assembly to set the stack pointer (<code>sp</code>) to the correct value should be the first useful instruction.</li> <li>Make sure the main function code is at the beginning. Some compilers such as gcc may put this in the end, in which case you need to rearrange the functions in assembly. Our absolute bare-metal system does not have a linker/loader/startup code to start at the main if it is not in the beginning.</li> <li>Simulate the code in RARS.</li> <li>When using memory-mapped input peripherals, the corresponding address location should be modified just before the corresponding lw is executed to simulate the data coming in from peripherals.</li> <li>If you are using the counter peripheral for delay, you might want to use a smaller delay for simulation and change the code to a bigger value later. This can be changed in C code or directly in assembly (likely lui)</li> <li>Though you can't see OLED output, it is fairly easy to check the row, column, pixel colour, and pixel write signals and get a sense.</li> <li>Export the instruction and data memory as hexadecimal text, overwriting the AA_IROM.mem and AA_DRAM.mem that are added to the Vivado project.</li> <li>Simulate in HDL behavioral sim, after changing the test_Wrapper to give stimuli according to the inputs expected by your C/assembly program.</li> <li>Finally, synthesize and generate bitstream. Fingers crossed :)</li> </ul>"},{"location":"lab4/Using_Compiled_Code/#using-new-peripherals","title":"Using New Peripherals","text":"<p>The new peripherals cycle counter, accelerometer, and OLED display peripheral register info can be found in the Wrapper HDL code.  </p>"},{"location":"lab4/Using_Compiled_Code/#cycle-counter","title":"Cycle Counter","text":"<p>Cycle counter gives the number of processor cycles that have elapsed since the last reset. Cycle counter rolls over at 42 seconds at 100 MHz (CLK_DIV_BITS = 0), but is much longer at lower frequencies. Change counter width and bits used in Wrapper.v for a longer duration, but lower cycles precision.  </p>"},{"location":"lab4/Using_Compiled_Code/#accelerometer","title":"Accelerometer","text":"<p>The accelerometer gives the temperature and X, Y, Z accelerations. ACCEL_DATA is a 32-bit value packing 4 independent 8-bit values  MSB downto LSB. Each value is in 8-bit signed format with a range of +/- 2g. So a reading of 1g is 0x40 and -1g is 0xC0. The sensor in fact gives a 12-bit reading, but uses only 8 bits for simplicity. The calibration is not perfect on all boards, so do not be surprised if there is a fixed offset to all your readings.   <p>If you want only a specific axis or temperature, use a combination of logical operators and shift e.g., extract Y using (*ACC_DATA_ADDR &amp; 0x0000FF00) &gt;&gt; 8. If your processor can do <code>lbu</code>, the required byte can be read directly.  </p> <p>ACCEL_DREADY indicates data readiness, which is useful only when attempting to read at a high rate.</p>"},{"location":"lab4/Using_Compiled_Code/#oled","title":"OLED","text":"<p>OLED uses PMOD B.</p> <p>The OLED controller has a built-in buffer, which means that your program does not have to keep feeding pixels continuously. Only changes need to be written.  </p> <p>Caution: Do not leave OLED on for too long unnecessarily, especially with the same frame. It can cause burn-in.  </p> <p>OLED_CTRL register functionality is described below.  </p> <p>OLED_CTRL[3:0] : Change that triggers write. We can vary one of them (e.g., column) while keeping the other two the same. This can be efficient in applications like  vector graphics, where replicating a pixel along a row or column is common. In the example program where a line with a specified colour is drawn, we vary only x (columns).</p> <ul> <li>0x0: vary_pixel_data_mode</li> <li>0x1: vary_COL_mode (x)</li> <li>0x2: vary_ROW_mode (y)</li> </ul> <p>OLED_CTRL[7:4] : Colour format.</p> <ul> <li>0x0: 8-bit colour mode: 1 byte per pixel, memory efficient especially if loading bitmapped images. Format: 3R-3G-2B.</li> <li>0x1: 16-bit colour mode: Highest colour depth supported by the OLED in a compact representation. It is the OLED native input format: 5R-6G-5B.  </li> <li>0x2: 24-bit colour mode: Similar to standard displays, but some LSBs are not used. Easier to visualise in simulation as each colour is a 2-hex digits. Wrapper output format: 5R-3(0)-6G-2(0)-5B-3(0).  </li> </ul>"},{"location":"lab4/Using_Compiled_Code/#loading-images","title":"Loading Images","text":"<p>The easiest way to load a raster image is to hard-code the array in C or assembly. This can be done easily using an online tool such as https://notisrac.github.io/FileToCArray/.  </p> <p>It is also possible to receive the image at runtime via UART or initialise it in your HDL via a .mem file. However, these will limit your ability to simulate in RARS.</p> <p>Before you think of loading a raster image - Make sure your data memory is big enough to hold the image. Adjust the depth/size in both HDL and C! A not-too-complex vector image may not need a memory size increase or memory configuration change.</p> <p>For a full-resolution raster image (96x64), the data memory size needed will exceed the 0x2000 size provided by the 'compact, text at 0' configuration that we have been using. You will have to resort to the RARS default configuration in this case. This requires changing</p> <ul> <li>initialization and reset value of the program counter in ProgramCounterv2 file (2 places in total) to 0x00400000.</li> <li>IROM_BASE and DMEM_BASE to 0x00400000 and 0x10010000 respectively in Wrapperv3 as well as the C code </li> <li>DMEM_DEPTH_BITS in Wrapperv3. A full-resolution image with even 8-bit colour mode requires 6144 bytes, which means a DMEM_DEPTH_BITS of at least 13! The C code DMEM_SIZE should be 2^DMEM_DEPTH_BITS which is 0x2000 for DMEM_DEPTH_BITS of 13.</li> </ul> <p>When you export byte arrays in the data segment from Godbolt to RARS, there could be an issue - RARS doesn't recognize the octal escape sequence emitted by compilers. A workaround is to copy-paste the actual C array into the data segment of RARS with a .byte declaration, instead of using the .ascii array emitted by the compiler. The rest of the generated assembly is fine. This is illustrated in the figures below.  </p> <p> C Code  </p> <p> Octal array emitted by the compiler  </p> <p> Copy-pasted array fix in RARS with .byte declaration</p> <p>Food for thought:</p> <ul> <li>It may be better to use synchronous read and use block RAMs if you have many images. Else, you will quickly run out of LUTs.</li> <li>Image pixels being sent column-wise is advantageous if the conversion tool can give a column-major format for the array. This is because multiplication by 64 is easier than by 96.</li> <li>Clang emits <code>mul</code> instructions when you multiply by 96, GCC does y*64+y*32 instead, in some optimization modes.</li> <li>It is not uncommon to allocate memory that is larger than the required size to make the buffer dimensions powers of two - trading off memory for performance!</li> <li>Possible enhancement: Implementing a mode where the row/column indices autoincrement in a row-major/column-major manner can accelerate the loading of raster images. Only one write per pixel will suffice, with the ability to feed data from a C array without maintaining separate row/column indices. You will need to implement some control bits in the control register to enable this (and an additional bit if you wish to allow the user to choose between row-major / column-major formats), along with other changes in the Wrapper. </li> <li>It is not possible to read back\u00a0what you wrote to the OLED. Something =\u00a0*OLED_DATA_ADDR does not work. These are memory-mapped peripherals; do not treat like memory. However, it is possible to modify the Wrapper and TOP to accomplish this, but has some issues such as needing 2 clock cycles for a read.</li> </ul>"},{"location":"lab4/additional_instructions/","title":"Lab 4 Enhancement: Implementing additional instructions","text":"<p>You may choose to implement some additional instructions for your processor for your enhancement, or features of instructions that have not been fully implemented. The score you get for this will depend on how much additional logic you need to add for these features.</p>"},{"location":"lab4/additional_instructions/#suggestions-for-risc-v","title":"Suggestions for RISC-V","text":"<ul> <li>Add support for byte and half-word load and store: <code>lb</code>, <code>lh</code>, <code>lbu</code>, <code>lhu</code>, <code>sb</code>, <code>sbu</code>.</li> </ul> <p>ReadData_in is the whole word that contains the word/half-word/byte you want. You need to extract out what you want, with sign/zero(<code>u</code>) extension as required by the instruction. For example, when running <code>lbu</code> (load byte unsigned) instruction, if the last 2 bits of the address is 2'b01, and the address location specified in the instruction has 8'hAB, ReadData_in is 32'hxxxxABxx. ReadData, the word to be written into the destination register is 32'h000000AB (0s as MSBs as it is <code>lbu</code>). For <code>lb</code>, ReadData_in[15] should be replicated to the 24 MSBs. You have to do this conversion.</p> <p>WriteData_out is a word, with word/byte/half-word aligned to where you wish to write it to within the word. The MemWrite_out bits of every byte to be modified should be 1. For example,when running <code>sb</code> (store byte) instruction, if the last 2 bits of the address is 2'b10 and the byte to be written is 8'hAB (or 32'b000000AB), WriteData_out should be 32'hxxABxxxx and MemWrite_out should be 4'h0100.You have to do this conversion. Another example: when running <code>sh</code> (store halfword), if the last 2 bits of the address is 2'b10 and the half-word to be written is 16'hABCD (or 32'h0000ABCD), WriteData_out should be 32'hABCDxxxx and MemWrite_out should be 4'h1100. You have to do this conversion.</p> <p>CAUTION: Unaligned data reads and writes are NOT supported. If the instruction is <code>lh</code>/<code>lhu</code>/<code>sh</code> (load/store halfword), the data memory address should be divisble by 2 (the last bit should be 0) If the instruction is <code>lw</code>/<code>sw</code>, the data memory address should be divisible by 4 (the last two bits should be 0s)</p> <p>Potential enhancement: Unaligned requests can be detected and used to generate interrupts by editing the wrapper. This interrupt could be used to do a software emulation of unaligned access via aligned access.</p> <ul> <li>Other ISA extensions: see the RISC-V Specification for ideas.</li> </ul>"},{"location":"lab4/additional_instructions/#suggestions-for-arm","title":"Suggestions for ARM","text":"<ul> <li>Implement all 16 Data Processing instructions. See Section \"A3.4 Data processing instructions\" in page A3-9 to A3-11 (page 75) of ARM\u00a0Architecture Reference Manual\u00a0for the details of the instructions. Page A3-11 has links to Sections 4.xx where the instruction behavior is explained in more detail.\u00a0Make sure you look at the ARM (32-bit) instructions, not Thumb (16-bit) instructions.</li> <li>It mainly involves modifying the ALU and the ALU Decoder.</li> <li>The C flag has to be an output from the CondLogic component/module, to act as an input for the ALU component/module (to support ADC instruction).</li> <li>Implement it efficiently, hopefully without additional adders.</li> <li>Support the additional multiplication instructions like <code>SMULL</code> and <code>UMULL</code>. There is not much point in implementing <code>SMLAL</code> and <code>UMLAL</code> since we already cannibalized the <code>MLA</code> instruction for division.</li> <li>Support other instructions like <code>SWP</code> and <code>BL</code>.</li> <li>Support other variants of existing instructions such as pre-indexed and post-indexed <code>LDR</code>/<code>STR</code>, Register Shifted Register Src2, <code>MUL</code> setting <code>Z</code> and <code>N</code> flags, etc.</li> <li>Support Src2 for DP instructions with rotated immediates.</li> <li>You can use the same shifter unit that we have used so far. Just make the appropriate connections.</li> <li>This will need a 32-bit mux at the shifter input, a 1-bit mux for <code>Shamt5[0]</code>\u00a0(which is '0' when\u00a0rot\u00a0is used), as well as a 2-bit mux for sh (which is \"11\" for immediate Src2) - all the muxes can be controlled using the same control signal.</li> <li>An alternative (more hardware efficient) is to move the shifter after the multiplexer controlled by <code>ALUSrc</code> (i.e., to just before SrcB of the ALU), and you can continue to use the same <code>ALUSrc</code> control signal. This will eliminate the need for a 32-bit multiplexer. However, you will need a 5-bit multiplexer for\u00a0Shamt5, with a 2-bit control signal - select <code>Shamt5</code> for register Src2, (<code>Shamt5[4:1], 0</code>) for immediate Src2 and <code>00000</code> for all others. A\u00a02-bit mux for sh will be required too, which selects \"11\" for immediate Src2, sh for register Src2, and either for all others (as the shift amount is zero for others anyway).</li> <li>Your shifter could be modified to generate a carry ('C') based on the last bit that is shifted out (<code>shifter_carry_out</code>). This can be used to set the carry flag for instructions such as <code>MOVS</code>, <code>ANDS</code>, <code>ORRS</code>, etc. (see ARM reference manual for the explanation of <code>MOVS</code> etc.).</li> <li>This will require <code>FlagW</code> to be used differently (now that 'C' and 'V' are not always written together).</li> <li>Effective 'C' will be instruction-dependent - need more logic to channel the appropriate carry into the input of 'C' flipflop/register. This logic can be inside the ALU (in which case the carry from the shifter will have to be an input to the ALU) or in the main ARM module.</li> </ul>"},{"location":"lab4/additional_instructions/#tips-for-arm","title":"Tips for ARM","text":"<ul> <li>You may require additional read/write ports for the register file. You could also use micro-operations to avoid the need for more than 2 read ports / more than two write ports for some of the instructions - you will need additional\u00a0logic to write results one by one over two cycles while PC is stalled. For example, for <code>SMULL</code>, <code>UMULL</code> etc, you can have an internal register (which is not in the visible register set) for storing the second word, to be written in the second cycle. You will also need to generate two sets of control signals - one for the first cycle and one for the second cycle. A multiplexer is required to select one of the two sets of control signals which are passed to the E pipeline register over successive clock cycles.</li> <li>You don't have to worry about how xPSR is dealt with in the special case of Rd=R15 as mentioned in the manual.</li> <li>Note that when I bit of the instruction is 0, and bit 7 and bit 4 of the instruction are both 1's, the instruction is not a usual DP instruction (could be <code>MUL</code> etc.).</li> <li>You can modify the ARM processor to work even for\u00a0<code>LDR PC,..</code> without that much of an effort. If <code>LDR</code> with PC as destination needs to be supported, we need to create a separate signal <code>PCWriteLDR</code> specifically for this case. <code>PCWriteLDRM + PCWriteLDRW</code> should stall D and Flush E., in addition to <code>PCSrcE</code> flushing D and E (effectively, we will be flushing 4 instructions).\u00a0You will need to retain the multiplexer as in the original circuit to enable the result read from the memory to go into PC. So essentially, you will have 2 multiplexers for PC input - one as in the original branch, and one for early BTA.</li> <li>Forwarding data from W to D will allow you to write register file at the positive edge, which will most likely reduce your critical path and improve the frequency at which your processor can operate.</li> </ul>"},{"location":"lab4/hazard/","title":"Lab 4 Enhancement: Resolving Hazards","text":"<p>Here are the general steps to add hardware to resolve hazards.</p> <ol> <li> <p>Resolve data hazards by adding the hazard hardware as shown in the lecture. Note that this will require creating additional pipeline entries such as <code>rs1E</code>, <code>rs2E</code>, <code>rdM</code>.</p> </li> <li> <p>Verify that your design works\u00a0still works. If not, it's time to debug. </p> </li> <li> <p>Change the design as given in Chapter 6.</p> </li> <li> <p>Verify that your design works\u00a0still works. If not, debug some more. </p> </li> <li> <p>Insert the control hazard hardware.</p> </li> <li> <p>Verify that your design works\u00a0still works. If it does, BINGO. You may need to clear (parts of) the pipeline registers to have proper initial values for the various outputs of the hazard unit.</p> </li> </ol> <p>While flushing a stage, the reset/CLR for the pipeline register feeding that stage is asserted, causing an <code>NOP</code> to go into that stage. An easier solution (for E and later stages) is to just reset only those bits which affects the machine state (such as <code>RegWriteE</code>, <code>MemWriteE</code> etc).</p>"},{"location":"lab4/interrupts/","title":"Lab 4 Enhancement: Interrupt generation and exception handling","text":"<p>You can implement some simple interrupt handling. There is no need to conform to the RISC-V interrupt architecture.</p> <p>External interrupt generation logic can be done inside the wrapper fairly easily. For example, if you want an interrupt to be raised when any of the pushbuttons are pressed, you can do interrupt = <code>PB[3] |\u00a0PB[2] |\u00a0PB[1] |\u00a0PB[0]</code>. This interrupt can be then be fed into ARM/RV module from the wrapper.</p> <p>Other possible exception/interrupt sources are  * other peripherals - e.g., counter from Wrapper * invalid memory address - <code>bad_MEM_addr</code> from the address decoder of Wrapper * unaligned address - easy to detect in Wrapper or RV. The additional instructions page has some info on it * illegal instruction - from your instruction decoder * division by zero - from MCycle</p> <p>Some other tips: * You can have a hardcoded exception handler address input to the multiplexer controlling the PC input. The interrupt input itself can be used as (part of the) multiplexer select input. *   You can write your interrupt service routine in your assembly code, figure out the starting address, and use this value as hardcoded input to the mux. An alternative is to decide on a fixed handler address, and fill up spaces/NOPs in your code until the handler starts address. For example, if you fix the handler starting address to be 0x100 and your 'main' program contains 30 instructions, you will need to add 34 NOPs before the first instruction in the handler code so that handler code will indeed be at 0x100. *   ARM: You should also have some mechanism to save <code>PC+4</code> into a register (say, <code>LR</code> in ARM) and to restore it when the handler has finished (use <code>MOV PC, LR</code> to return from the handler). *  RISC-V: The address of the instruction that caused the exception/ that was about to be executed when an interrupt came in is saved into epc^ (exception program counter, and not <code>ra</code>). Since we aren't aiming for compliance, saving automatically to another general purpose register that isn't used in your program is an option too. Saving to <code>ra</code> can be problematic when you have function calls as <code>ra</code> gets overwritten. You can then use <code>jalr</code> aka <code>jr</code> to return from interrupt.  ^ Note that epc is not a register that cannot be used like a general purpose register. You need <code>csrr</code> to move its content to a general purpose register. *   If you wish to have vectored interrupts, you need to associate a number with each interrupt. You need a table/ROM with the starting addresses, which will be indexed by the interrupt number. The output of this ROM is to be fed into the PC multiplexer. The PC multiplexer control signal can be the logical OR of all the interrupt lines.</p>"},{"location":"lab4/lab4/","title":"Lab 4: (Near) Complete Processor + Pipelining + Bells + Whistles","text":"<p>Lab 4 involves 2 compulsory tasks and the rest is open-ended.</p> <p>Demonstrate [Post-synthesis simulation and FPGA hardware] incorporating all the mandatory and open-ended parts. Use a single assembly program that can be entirely compiler-generated, entirely hand-crafted, or a combination of the two.</p>"},{"location":"lab4/lab4/#compulsory-task-1-5-marks","title":"Compulsory Task 1 [5 marks]","text":"<p>Add support for the following previously unsupported instructions/features mentioned below. They are pretty easy to add at this point and will allow you to run almost all the code generated by a compiler. Please see Using Compiled Code and New Peripherals page for more info. However, using hand-coded assembly is perfectly fine too.</p> <p>There is no need to try and craft a program specifically to demonstrate everything below, unlike in the previous labs. The only requirement is to have at least one function call in your program, which will cause <code>jal</code> (<code>call</code>) and <code>jalr</code> (<code>ret</code>) to be emitted by the compiler, unless you do a whole program optimization with GCC. * DP instructions: <code>xor</code>, <code>xori</code>, <code>slt</code>, <code>sltu</code>, <code>slti</code>, <code>sltiu</code>, <code>slli</code>, <code>srli</code>, <code>srai</code>. * Branch instructions: <code>blt</code>, <code>bge</code>, <code>bltu</code>, <code>bgeu</code>, <code>jal</code> (with support for linking: i.e. <code>rd = PC + 4</code>), <code>jalr</code>.  * Multiply (M) instructions: <code>mulh</code>, <code>mulhu</code>, <code>div</code>, <code>rem</code>, <code>remu</code>. <code>mulhsu</code> is NOT a requirement, as it requires some additional effort. <code>mulhsu</code> can be avoided in the compiler-generated code by avoiding signed x unsigned multiplications.</p> <p>Support for byte and half-word load / store is NOT a basic requirement. They can be mostly avoided by using only <code>int</code>s in your program. However, incorporating them can lead to easier to write and more efficient programs, especially when using byte-oriented peripherals such as the UART console, 8-bit images with OLED, etc.</p>"},{"location":"lab4/lab4/#compulsory-task-2-10-marks","title":"Compulsory Task 2 [10 marks]","text":"<p>Implement basic pipelining. Hazard hardware is optional and will count as an open-ended enhancement if done, but it is not counted for the compulsory task marks. Pipelining should be done such that the processor supports all the requirements for Lab 2, Lab 3, and the additional instructions / features mentioned in Lab 4 Compulsory Task 1 above.</p> <p>As long as your code works after inserting the sufficient <code>NOP</code>s, this task requirement can be satisfied. If you have full hazard hardware, of course, <code>NOP</code>s are unnecessary.</p> <p>For some tips on implementing pipelining, see this page.</p> <p>The real benefit of pipelining is higher clock speeds. For example, it's highly unlikely that your design runs at 100 MHz without pipelining. You'll most likely get a critical warning that some timing constraints are not met. The design may or may not run on the board, but if you got a timing warning, the functionality is not reliable. It's pointless to have a pipelined design that runs at 1 Hz. So it is a good idea to think of an application program that benefits from the higher clock speeds. Frequencies of up to 100 MHz can be achieved by changing CLK_DIV_BITS in TOP.vhd.</p>"},{"location":"lab4/lab4/#open-ended-enhancement-10-marks","title":"Open-ended Enhancement [10 marks]","text":"<p>This is the fun part - you get 10 marks for Lab 4 for implementing performance enhancements of your choice. There is no fixed requirement to get these marks, and while we suggest some enhancements below, it doesn't mean you need to implement all (or any!) of these. Just one significant performance enhancement will suffice, and this need not be limited to the ones we have listed.</p> <p>Some potential improvements you can think about implementing are:</p> <ul> <li>Implement hazard detection and resolution</li> <li>Implement additional instructions</li> <li>Implement exception handling and interrupt support</li> <li>Implement basic branch prediction</li> <li>Use other devices, especially if they can be used to illustate performance enhancements. e.g., built in mic (could be interesting), RGB LEDs (not too interesting), USB host, etc. Not too difficult using components/modules from https://github.com/Digilent/Nexys-4-DDR-OOB</li> </ul>"},{"location":"lab4/lab4/#design-instructions","title":"Design Instructions","text":"<ul> <li>You are encouraged to have your own, comprehensive programs to have a convincing demo.</li> <li>You may have to tweak the templates given in Lab 2 for use in Lab 4. Specifically, you will have to change the ALUControl to 4 bits for ARM, PCSrc and ALUSrcA/B width for RISC-V, etc.</li> <li>All 32-bit combinational arithmetic and logical operations have to be performed inside the ALU. Exceptions: <code>+</code> for calculating <code>PC+4</code>, <code>PC+8</code> (in ARM), multiplication, division, enhancements such as branch prediction.\u00a0Pipeline hazard detection will require comparisons (for equality only) too, but they are on 5-bit values.</li> <li>In the ALU, DO NOT use additional <code>+</code> signs -&gt; this could infer additional adders. The existing addition framework should be good enough.</li> <li>All operators are permitted on 32-bit values outside the ARM/RISC-V module. For example, you will have to do 32-bit comparisons in the wrapper for address decoding.</li> <li>Use of arithmetic operators  <ol> <li>Do not use <code>*</code> operator. It is synthesizable, but in this course, we are implementing multi-cycle multiplication. <code>/</code> is not synthesizable, except on constants.</li> <li>All operators (including <code>**</code>, <code>*</code>, <code>/</code>, <code>sll</code>, <code>rem</code>, <code>mod</code> etc.) are allowed on constants (operations on constants are done at synthesis time, and will not infer any hardware).</li> </ol> </li> </ul>"},{"location":"lab4/lab4/#submission-info","title":"Submission Info","text":"<ul> <li>Lab 4 will be evaluated in Week 12. The presentation schedule can be found on Canvas.</li> <li>Include</li> <li>.v/vhd\u00a0files you have created/modified [\u00a0RTL Sources, Testbench(es) ]</li> <li>.c/h files used to generate assembly</li> <li>.bit\u00a0files</li> <li>.s/.asm files (assembly programs)</li> <li>.ppt\u00a0file - 2 to 6 slides showing performance enhancement techniques you have implemented.</li> </ul> <p>in an archive with the filename\u00a0GroupXX_Monday/Friday_Lab4.zip (replace XX with your group number) and upload it to Canvas. One submission per group is sufficient \u2013 if there are multiple submissions, the file with the latest timestamp will be taken as the final submission. Do not\u00a0zip and upload the complete project folder \u2013\u00a0only those files mentioned above should be included.\u00a0The files should be the exact same files that you used for the demo.</p>"},{"location":"lab4/pipeline/","title":"Lab 4: Implementing Pipelining","text":"<p>This page will guide you through how to implement basic pipelining for the mandatory task for Lab 4.</p>"},{"location":"lab4/pipeline/#notes","title":"Notes","text":"<ul> <li>The WE of the PC given in the templates is active high, while the one given in the pipelined design (Chapter 6) is active low. You might want to change the PC WE in the templates to active low to be consistent.</li> <li>Even though the pipeline registers are shown as big registers storing a lot of stuff, each data stored can be thought of as being in a separate register. In other words, in your HDL code, you don't have to try and 'collect' all the bits to form a single register entity.</li> </ul>"},{"location":"lab4/pipeline/#systematic-procedure-for-pipelining","title":"Systematic procedure for Pipelining","text":"<p>Follow these steps to implement pipelining.</p> <ol> <li> <p>Start by inserting the appropriate suffixes (F/D/E/M/W) for each wire, port, register, and signal. Refer to slide 11 of chapter 6 for this. For every signal that goes through multiple pipeline stages, it will need to be split into two signals, separated by a pipeline register. Note: Generally, the signals going into every component will have the same suffix, since every component is part of one and only one pipeline stage. The exception to this is the register file, where <code>A3</code> and <code>WD3</code> (ARM) or <code>WD</code> (RISC-V).</p> </li> <li> <p>Make the appropriate datapath connection(s) for every signal going through a pipeline register. Some connections were made implicitly, such as ALUControl. These connections will need to be made explicitly. For RISC-V, a multiplexer must be inserted to select between <code>PC_F</code> and <code>PC_E</code>, controlled by <code>PCSrc_E</code>. Remember to change the datatype from <code>wire</code> to <code>reg</code> where necessary.</p> </li> <li> <p>Verilog: Use a combinational always block with non-blocking assignments. For example:</p> </li> </ol> <p><code>always @(*) begin    ExtImm_E &lt;= ExtImm_D;   end</code></p> <p>in ARM.v or RV.v</p> <ul> <li> <p>VHDL: Use a concurrent statement (NOT inslude a clocked process for now). For example, <code>ExtImm_E &lt;= ExtImm_D;</code> in ARM.vhd</p> </li> <li> <p>Verify that your design works EXACTLY as it did previously, without any changes to the assembly language program. We have NOT yet inferred any registers, so there should not be any pipelining going on (yet!). If something has broken, now is a good time to debug it.</p> </li> <li> <p>Now, we implement the pipeline registers.</p> </li> <li> <p>VHDL: Move all move all the signals which are supposed to go through a particular pipeline register into\u00a0one clocked process in ARM/RISC-V architecture\u00a0(everything in one big clocked process is fine too, but it is better to keep it in separate process for better organization).</p> </li> <li> <p>Verilog: Change the combinational <code>always @(*)</code> to <code>always @(posedge clk)</code>.</p> </li> <li> <p>Initialize all all your signals and registers to zero Add a condition that sets all these signals and registers to zero when RESET is asserted, and otherwise, assigns the RHS to the LHS at the clock edge.</p> </li> <li> <p>Modify the Register file slightly, to read the clock at negative edges:</p> </li> <li> <p>VHDL: <code>CLK'event and CLK='1'</code> becomes <code>CLK'event and CLK='0'</code>.</p> </li> <li> <p>Verilog: <code>always @(posedge clk)</code> becomes <code>always @(negedge clk)</code>.</p> </li> <li> <p>Your processor should now be pipelined, so now your old program may not work as it did. You will need to add <code>NOP</code>s wherever there is any kind of hazard, to avoid these. For a start, just insert NOPs such that each pair of instructions having a data hazard are spaced by at least 2 instructions (for example, insert 2 NOPs if the two instructions are consecutive). After each branch, insert 4 NOPs.</p> </li> <li> <p>Verify that your design works\u00a0as it used to (it will just be slower because of all the NOPs).</p> </li> </ul> <p>For hazard resolution hardware (not a basic requirement), follow the design in Chapter 5. Do it systematically and incrementally, one hazard at a time, and testing at each step.</p>"},{"location":"lab4/pipeline/#increasing-the-clock-speed","title":"Increasing the clock speed","text":"<p>Now that you have pipelined your processor, you might be able to run it without any clock division, at the full 100 MHz, especially . Change <code>CLK_DIV_BITS</code> to test if this is the case.</p> <p>However, note that even with the standard 5-stage pipeline, 100 MHz may not always be achievable, especially if your memory size is big. Up to ~430 MHz is possible though unlikely with a 5-stage pipeline. To increase clock beyond 100 MHz, you will need to make use of the FPGA built-in clocking resource called MMCM (which used phase locked loops). This can be configured using a clocking wizard.</p> <p>Tip for faster clock speeds: Identify the bottleneck by looking at that timing report.</p> <ul> <li>Use smaller memories.</li> <li>For larger memories, use block ram templates, and allow at least 2 clock edges, and maybe even 3 for a read. This of course is a major design change as the pipeline is no longer 5 stage</li> <li>Use a hierarchy of memories.</li> <li>If the bottleneck is the execute stage, try to make it shorter by moving the PC logic to M stage.</li> </ul>"},{"location":"vivado_install_guide/vivado_install_guide/","title":"Installation Guide for Vivado","text":"<p>For this course, we recommend using Vivado 2023.2. Any other version of Vivado you have installed will probably work; however, you will need support for 7 series FPGAs to be able to use the Nexys 4 board. </p> <p>Important note: Vivado runs on Windows and Linux, but not on macOS. Our testing has found that if you use a Windows VM with Parallels Desktop, USB passthrough for the FPGA board doesn't work correctly. However, you can still use the simulation tools, and RARS will run (that will run natively on macOS too), so it's still better than nothing. This guide will be updated if we find any workarounds to this issue. </p> <p>Download Vivado from AMD/Xilinx's website. We echo AMD's recommendation to download the web installer instead of the full, 100+ gigabyte archive. Download the exe or bin file, depending on your operating system of choice. </p> <p>You will need to create an account to download Vivado and fill out a form for US export control regulations. You will also need to enter this information when you install the software. </p>"},{"location":"vivado_install_guide/vivado_install_guide/#preparing-to-install-vivado","title":"Preparing to install Vivado","text":""},{"location":"vivado_install_guide/vivado_install_guide/#windows","title":"Windows","text":"<p>You should be running Windows 10 or 11. Xilinx recommends the Pro or Enterprise version of certain specific versions of Windows; however, Vivado runs just fine on any version of 10 or 11. Simply open the downloaded executable file. Make sure you allow it through your firewall when prompted, and note that it may show up as \"OpenJDK Platform Binary\" executable requesting permission. </p>"},{"location":"vivado_install_guide/vivado_install_guide/#linux-ubuntu-rhel-etc","title":"Linux (Ubuntu, RHEL, etc.)","text":"<p>To install Vivado on Linux, you may first need to install some dependencies. On Ubuntu, these are <code>libtinfo5</code> and <code>libncurses5</code>. Install these with <code>sudo apt install libtinfo5 libncurses5</code>. Some googling will find you the equivalent packages and commands for other distributions like Red Hat/Fedora and Arch. Xilinx officially supports some specific versions of RHEL, CentOS, SLE, Amazon Linux, AlmaLinux and Ubuntu; however, Vivado will probably run on other distributions like Fedora or Arch. </p> <p>Additionally, for Linux, the installer will not automatically install cable drivers for you. After you install Vivado, you must follow the following steps:</p> <pre><code># change directory to your Vivado install, for example:\ncd /opt/Xilinx/Vivado/2019.2\n\n# cd into the drivers directory (the script MUST be run there)\ncd data/xicom/cable_drivers/lin64/install_script/install_drivers\n\n# run the cable installer with root privileges\nsudo ./install_drivers\n</code></pre> <p>These steps can also be found on Xilinx support.</p> <p>To run the installer, first use <code>chmod u+x filename.bin</code> to add execute permissions to the downloaded bin file. Remember to replace \"filename\" with the name/path of the downloaded file. Run it using <code>sudo ./filename.bin</code>. </p>"},{"location":"vivado_install_guide/vivado_install_guide/#_1","title":"Installation Guide for Vivado","text":"<p>The installer may ask you to install the latest version of Vivado instead. </p> <p></p> <p>Ignore this and click \"Continue\" instead. </p> <p>This will bring you to the Welcome page of the installer, shown below. </p> <p></p> <p>Click \"Next\" to proceed. </p> <p>The installer will now prompt you to enter your username and password you created to authenticate the download. </p> <p></p> <p>Enter your username and password you just created. Make sure you have \"Download and Install Now\" selected. Click \"Next\". </p> <p>You will now see the following screen, asking you which product you would like to install:</p> <p></p> <p>Here, choose Vivado. You will not need Vitis for this course; however, it will be needed for EE4218 and CEG5203, so if you intend to take either course in the future, select Vitis instead. Click \"Next\". </p> <p>Next, you will be prompted for which edition of Vivado you want to install. This prompt will not appear if you chose to install Vitis instead. </p> <p></p> <p>Here, choose the Vivado ML Standard edition. Beware that Vivado ML Enterprise is selected by default. </p> <p>Now, you will be prompted to choose which components you want to install. If you are installing only Vivado for CG3207, then make the following selections: </p> <p></p> <p>Make sure Artix-7 (under the 7 Series devices), and the \"Install Cable Drivers\" option, are checked. </p> <p>If you are installing Vitis, and want to install the components you will need later, make the following selections:</p> <p></p> <p>Make sure Artix-7 (under the 7 Series devices), and Zynq UltraScale+ MPSoC (under the SoCs) are checked, as well as \"Install Devices for Kria SOMs and Starter Kits\". Also make sure \"Install Cable Drivers\" is selected. </p> <p>Click \"Next\" to proceed. You will now be prompted to accept the license agreements for all the products you are installing. </p> <p></p> <p>Check all the \"I Agree\" checkboxes, and click \"Next\" again.</p> <p>The last screen will prompt you for the installation destination and other options. You may choose to stick with the defaults, or change these as per your preference. </p> <p></p> <p>Click \"Next\" here. The installer will then prompt you to confirm your selections.</p> <p></p> <p>Make sure all the options shown are correct for what you're trying to install. Click Install and let the installer run, it may take a while (up to a couple of hours). </p>"},{"location":"vivado_install_guide/vivado_install_guide/#next-steps","title":"Next Steps","text":"<p>You may wish to see the Getting Started manual which teaches you some of the basics of how to use Vivado and Verilog to create a design for an FPGA. </p>"}]}